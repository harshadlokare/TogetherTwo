<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Co-Op Platformer: Together Trials</title>
  <style>
    :root{
      --bg1:#0b1020; --bg2:#0d1b2a;
      --ui:#0f172a; --ui2:#111827;
      --txt:#e5e7eb; --muted:#9ca3af;
      --boy:#3b82f6; --boy2:#93c5fd;
      --girl:#a855f7; --girl2:#f472b6;
      --good:#22c55e; --warn:#f59e0b; --bad:#ef4444;
      --plat:#1f2937; --plat2:#374151;
      --switch:#16a34a; --door:#f59e0b; --trap:#ef4444; --goal:#22c55e;
    }
    html,body{height:100%;margin:0;background:radial-gradient(1200px 700px at 50% 20%, #1b2a57 0%, var(--bg1) 35%, #070a14 100%); color:var(--txt); font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
    #wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;}
    canvas{width:100%;height:100%;display:block;touch-action:none;}
    .hud{
      position:fixed;left:12px;top:12px;right:12px;display:flex;gap:10px;align-items:stretch;pointer-events:none;
      filter: drop-shadow(0 12px 18px rgba(0,0,0,.35));
    }
    .panel{
      pointer-events:none;
      background:linear-gradient(180deg, rgba(17,24,39,.86), rgba(15,23,42,.72));
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      padding:10px 12px;
      backdrop-filter: blur(10px);
      display:flex;gap:10px;align-items:center;
    }
    .panel .title{font-weight:700;letter-spacing:.3px}
    .panel .sub{color:var(--muted);font-size:12px;margin-top:2px}
    .panel .pill{
      display:inline-flex;align-items:center;gap:6px;
      padding:4px 9px;border-radius:999px;
      background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.10);
      font-size:12px;color:var(--txt);
    }
    .dot{width:10px;height:10px;border-radius:999px;display:inline-block}
    .dot.boy{background:var(--boy)}
    .dot.girl{background:var(--girl)}
    .dot.goal{background:var(--goal)}
    .dot.warn{background:var(--warn)}
    .right{margin-left:auto}
    .kbd{
      display:inline-flex;gap:6px;flex-wrap:wrap;
      font-size:12px;color:var(--muted);
    }
    .key{padding:3px 7px;border-radius:8px;background:rgba(0,0,0,.22);border:1px solid rgba(255,255,255,.08);color:var(--txt)}
    .overlay{
      position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
      background:radial-gradient(800px 500px at 50% 30%, rgba(59,130,246,.12), rgba(0,0,0,.55) 60%, rgba(0,0,0,.75) 100%);
      padding:18px;
    }
    .card{
      width:min(720px, 96vw);
      border-radius:18px;
      background:linear-gradient(180deg, rgba(17,24,39,.92), rgba(2,6,23,.82));
      border:1px solid rgba(255,255,255,.12);
      box-shadow:0 24px 70px rgba(0,0,0,.55);
      padding:18px 18px 14px;
      backdrop-filter: blur(10px);
    }
    .row{display:flex;gap:14px;align-items:center;flex-wrap:wrap}
    h1{font-size:20px;margin:0 0 8px;letter-spacing:.2px}
    p{margin:6px 0;color:var(--muted);line-height:1.35}
    .cols{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:10px}
    .box{
      border-radius:14px;
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      padding:10px 12px;
    }
    .box h2{font-size:13px;margin:0 0 6px;color:#fff;letter-spacing:.2px}
    .box ul{margin:0;padding-left:18px;color:var(--muted);font-size:12px;line-height:1.4}
    .btns{display:flex;gap:10px;justify-content:flex-end;margin-top:12px;flex-wrap:wrap}
    button{
      pointer-events:auto;
      appearance:none;border:0;
      padding:10px 12px;border-radius:12px;
      background:linear-gradient(180deg, rgba(59,130,246,.95), rgba(37,99,235,.85));
      color:white;font-weight:700;letter-spacing:.2px;
      border:1px solid rgba(255,255,255,.14);
      box-shadow:0 12px 26px rgba(37,99,235,.28);
      cursor:pointer;
    }
    button.secondary{
      background:linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
      color:var(--txt);
      box-shadow:none;
    }
    button:active{transform:translateY(1px)}
    .footer{display:flex;align-items:center;justify-content:space-between;margin-top:10px;color:var(--muted);font-size:12px;gap:10px;flex-wrap:wrap}
    .tag{
      display:inline-flex;align-items:center;gap:6px;
      padding:4px 8px;border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.06);
      color:var(--txt);
      font-size:12px;
    }
    .sr{position:absolute;left:-9999px}
    @media (max-width:620px){
      .cols{grid-template-columns:1fr}
      .hud{left:10px;right:10px}
      .panel{padding:9px 10px;border-radius:12px}
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="c"></canvas>
  </div>

  <div class="hud" aria-hidden="true">
    <div class="panel">
      <div>
        <div class="title">Together Trials</div>
        <div class="sub"><span class="pill"><span class="dot warn"></span><span id="lvlLabel">Level 1/7</span></span> <span class="pill"><span class="dot goal"></span><span id="objective">Reach goal together</span></span></div>
      </div>
    </div>
    <div class="panel right">
      <span class="pill"><span class="dot boy"></span>Boy <span id="boyState" style="color:var(--muted)">Idle</span></span>
      <span class="pill"><span class="dot girl"></span>Girl <span id="girlState" style="color:var(--muted)">Idle</span></span>
      <span class="pill">Time <span id="timeLabel" style="margin-left:6px;font-variant-numeric:tabular-nums">0.0s</span></span>
      <span class="pill">Deaths <span id="deathLabel" style="margin-left:6px;font-variant-numeric:tabular-nums">0</span></span>
    </div>
  </div>

  <div id="overlay" class="overlay">
    <div class="card">
      <div class="row">
        <h1 id="screenTitle">Together Trials — Co-op Platformer</h1>
      </div>
      <p id="screenDesc">Two players, one keyboard. Doors open only when you cooperate. Movement is precise: press to move, release to stop.</p>

      <div class="cols">
        <div class="box">
          <h2><span class="dot boy" style="margin-right:8px;vertical-align:-1px"></span>Player 1 (Boy)</h2>
          <ul>
            <li>Move: <span class="key">A</span> <span class="key">D</span> (and <span class="key">W</span>/<span class="key">S</span> on ladders)</li>
            <li>Jump: <span class="key">Space</span> (grounded only)</li>
          </ul>
        </div>
        <div class="box">
          <h2><span class="dot girl" style="margin-right:8px;vertical-align:-1px"></span>Player 2 (Girl)</h2>
          <ul>
            <li>Move: <span class="key">←</span> <span class="key">→</span> (and <span class="key">↑</span>/<span class="key">↓</span> on ladders)</li>
            <li>Jump: <span class="key">Ctrl</span> (Left/Right Control)</li>
          </ul>
        </div>
      </div>

      <div class="footer">
        <span class="tag"><span class="dot warn"></span>Co-op rules: switches reset if anyone leaves</span>
        <span class="tag"><span class="dot goal"></span>Finish only when both stand in the goal</span>
      </div>

      <div class="btns">
        <button class="secondary" id="btnHow">Level Rules</button>
        <button id="btnStart">Start</button>
      </div>
      <p class="sr" id="srStatus" aria-live="polite"></p>
    </div>
  </div>

  <script>
  (() => {
    // ---------- Canvas ----------
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { alpha: false });

    function resize(){
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      const w = Math.max(1, Math.floor(window.innerWidth));
      const h = Math.max(1, Math.floor(window.innerHeight));
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      canvas.style.width = w + "px";
      canvas.style.height = h + "px";
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    window.addEventListener('resize', resize, { passive:true });
    resize();

    // ---------- Audio (Web Audio API) ----------
    let audioCtx = null;
    function getAudio(){
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      return audioCtx;
    }
    function beep(type="sine", freq=440, dur=0.06, gain=0.08){
      const ac = getAudio();
      const t0 = ac.currentTime;
      const o = ac.createOscillator();
      const g = ac.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(gain, t0 + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      o.connect(g); g.connect(ac.destination);
      o.start(t0); o.stop(t0 + dur + 0.02);
    }
    function chord(freqs, dur=0.10, gain=0.06){
      freqs.forEach((f,i)=>beep("triangle", f, dur + i*0.02, gain));
    }

    // ---------- Utilities ----------
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp=(a,b,t)=>a+(b-a)*t;
    const now=()=>performance.now();

    function aabbIntersect(a,b){
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }
    function rect(x,y,w,h){ return {x,y,w,h}; }

    // ---------- Input: deterministic, last-press-wins ----------
    const keyDown = new Set();
    const lastPressTime = new Map();

    window.addEventListener('keydown', (e) => {
      const k = e.code;
      if (!keyDown.has(k)){
        keyDown.add(k);
        lastPressTime.set(k, performance.now());
      }
      // prevent scrolling from arrows/space
      if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(k)) e.preventDefault();
      // allow overlay buttons to work without focus issues
      if ((state.mode !== "play") && (k === "Enter" || k === "Space")) e.preventDefault();
    }, { passive:false });

    window.addEventListener('keyup', (e) => {
      keyDown.delete(e.code);
      if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) e.preventDefault();
    }, { passive:false });

    function lastWins(keys){ // keys: array of codes
      let best = null, bestT = -1;
      for (const k of keys){
        if (!keyDown.has(k)) continue;
        const t = lastPressTime.get(k) ?? 0;
        if (t > bestT){ bestT = t; best = k; }
      }
      return best; // code or null
    }

    // ---------- Game State ----------
    const overlay = document.getElementById('overlay');
    const btnStart = document.getElementById('btnStart');
    const btnHow = document.getElementById('btnHow');
    const screenTitle = document.getElementById('screenTitle');
    const screenDesc = document.getElementById('screenDesc');
    const lvlLabel = document.getElementById('lvlLabel');
    const objectiveEl = document.getElementById('objective');
    const timeLabel = document.getElementById('timeLabel');
    const deathLabel = document.getElementById('deathLabel');
    const boyStateEl = document.getElementById('boyState');
    const girlStateEl = document.getElementById('girlState');
    const srStatus = document.getElementById('srStatus');

    const state = {
      mode: "start", // start, play, levelComplete, gameOver, pause
      levelIndex: 0,
      deaths: 0,
      levelTime: 0,
      totalTime: 0,
      msgTimer: 0,
      msg: "",
    };

    // ---------- Physics / World ----------
    const PHYS = {
      g: 2100,             // px/s^2
      jumpV: 820,          // px/s
      moveV: 360,          // px/s (instant)
      airMoveV: 360,       // keep deterministic even in air
      maxFall: 1450,
      step: 1/120,         // fixed timestep for deterministic sim
    };

    // Camera keeps both players visible; zooms out if separated
    const cam = { x:0, y:0, z:1, targetZ:1 };

    // ---------- Level System ----------
    function mkMovingPlatform(x,y,w,h, axis, a, b, speed){
      return { type:"mplat", x,y,w,h, axis, a,b, speed, t:0, dir:1, vx:0, vy:0, carry:true };
    }
    function mkDoor(x,y,w,h, id){
      return { type:"door", x,y,w,h, id, open:false, anim:0 };
    }
    function mkSwitch(x,y,w,h, id, label="", require="both", kind="hold"){
      // require: both | boy | girl
      // kind: hold (resets if leave) | timedSync (must be pressed nearly simultaneously)
      return { type:"switch", x,y,w,h, id, label, require, kind, pressed:false, anim:0, lastPress: -1 };
    }
    function mkGoal(x,y,w,h){
      return { type:"goal", x,y,w,h, anim:0 };
    }
    function mkLadder(x,y,w,h){
      return { type:"ladder", x,y,w,h };
    }
    function mkTrap(x,y,w,h, kind="spike", cycle=0){
      // cycle 0 => always; else time-based on/off
      return { type:"trap", x,y,w,h, kind, cycle, t:0, on:true, anim:0 };
    }
    function mkHint(x,y,w,h, text){
      return { type:"hint", x,y,w,h, text, seen:false };
    }

    const levels = [
      // Level 1 — Basic Coordination: Floor switch + jump platforms
      () => ({
        name: "Basic Coordination",
        objective: "Hold the switch together to open the door, then reach the goal together.",
        spawn1: {x:140,y:640}, spawn2:{x:200,y:640},
        bounds: {minX:-200, maxX:2800, minY:-600, maxY:1100},
        platforms: [
          rect(-200,720,3200,80),
          rect(420,610,160,22),
          rect(640,520,170,22),
          rect(880,450,200,22),
          rect(1180,520,180,22),
          rect(1420,600,230,22),
          rect(1840,640,260,22),
          rect(2200,650,280,22),
        ],
        entities: [
          mkSwitch(270,692,120,22,"doorA","Switch A","both","hold"),
          mkDoor(520,660,60,60,"doorA"),
          mkHint(240,640,220,70,"Stand together on Switch A to open the door. Leaving resets it."),
          mkGoal(2500,590,120,130),
        ],
        hazards: [],
      }),

      // Level 2 — Timed Movement: Simultaneous button presses
      () => ({
        name: "Timed Movement",
        objective: "Press both switches almost at the same time to unlock the door.",
        spawn1: {x:80,y:640}, spawn2:{x:160,y:640},
        bounds: {minX:-200, maxX:3200, minY:-600, maxY:1300},
        platforms: [
          rect(-200,720,3800,80),
          rect(500,640,140,22),
          rect(720,560,140,22),
          rect(940,480,140,22),
          rect(1160,400,160,22),
          rect(1420,460,220,22),
          rect(1700,560,240,22),
          rect(2060,640,220,22),
          rect(2380,640,220,22),
        ],
        entities: [
          mkSwitch(540,612,120,22,"syncDoor","Boy Pad","boy","timedSync"),
          mkSwitch(2440,612,120,22,"syncDoor","Girl Pad","girl","timedSync"),
          mkDoor(1600,500,70,140,"syncDoor"),
          mkHint(360,632,280,70,"Level 2: Pads must be pressed within 0.25s. If anyone leaves, it resets."),
          mkGoal(3000,590,120,130),
        ],
        hazards: [],
      }),

      // Level 3 — Moving Platforms: One controls motion, other jumps
      () => ({
        name: "Moving Platforms",
        objective: "Boy holds the control pad to move the platform. Girl rides it across. Then reunite at the goal.",
        spawn1: {x:120,y:640}, spawn2:{x:210,y:640},
        bounds: {minX:-300, maxX:3600, minY:-700, maxY:1400},
        platforms: [
          rect(-300,720,4200,80),
          rect(520,650,180,22),
          rect(920,650,180,22),
          rect(1320,650,180,22),
          rect(1860,610,230,22),
          rect(2280,530,220,22),
          rect(2720,480,240,22),
          rect(3160,560,260,22),
        ],
        entities: [
          mkSwitch(520,622,160,22,"mover","Control","boy","hold"),
          mkDoor(760,660,60,60,"mover"),
          mkMovingPlatform(1100,610,170,20,"x", 1080, 1680, 240),
          mkHint(300,632,350,70,"Boy: stand on Control to activate the mover. Door opens only while held."),
          mkGoal(3420,590,120,130),
        ],
        hazards: [
          mkTrap(2100,698,80,22,"spike",0),
          mkTrap(2140,698,80,22,"spike",0),
        ],
      }),

      // Level 4 — Vertical Ascent: Ladder + jump coordination
      () => ({
        name: "Vertical Ascent",
        objective: "Climb together. Door opens only if both are on the top pads.",
        spawn1: {x:160,y:640}, spawn2:{x:240,y:640},
        bounds: {minX:-300, maxX:2400, minY:-1100, maxY:1200},
        platforms: [
          rect(-300,720,3000,80),
          rect(520,610,220,22),
          rect(520,470,220,22),
          rect(520,330,220,22),
          rect(520,190,220,22),
          rect(920,130,220,22),
          rect(1280,60,260,22),
          rect(1680,-20,260,22),
          rect(1960,120,260,22),
        ],
        entities: [
          mkLadder(600,210,80,510),
          mkSwitch(1700,-48,120,22,"topDoor","Top A","both","hold"),
          mkSwitch(1980,92,120,22,"topDoor","Top B","both","hold"),
          mkDoor(2140,20,70,170,"topDoor"),
          mkHint(60,632,340,70,"Use ladder: W/S and ↑/↓. Jump only when grounded. Top pads must be held together."),
          mkGoal(2280,10,120,130),
        ],
        hazards: [
          mkTrap(940,698,80,22,"spike",0),
          mkTrap(980,698,80,22,"spike",0),
        ],
      }),

      // Level 5 — Split Responsibility: One disables traps, one advances
      () => ({
        name: "Split Responsibility",
        objective: "One player holds the disable pad while the other crosses the traps. Then reunite.",
        spawn1: {x:120,y:640}, spawn2:{x:200,y:640},
        bounds: {minX:-300, maxX:3600, minY:-700, maxY:1400},
        platforms: [
          rect(-300,720,4200,80),
          rect(540,640,280,22),
          rect(980,580,260,22),
          rect(1400,520,260,22),
          rect(1820,520,260,22),
          rect(2220,580,260,22),
          rect(2680,640,300,22),
        ],
        entities: [
          mkSwitch(560,612,160,22,"trapOff","Disable","both","hold"),
          mkDoor(820,660,60,60,"trapOff"),
          mkHint(280,632,410,70,"Hold Disable to turn off red traps. If anyone leaves the pad, traps return."),
          mkGoal(3300,590,120,130),
        ],
        hazards: [
          mkTrap(1120,698,120,22,"laser",1.4),
          mkTrap(1500,698,120,22,"laser",1.2),
          mkTrap(1900,698,120,22,"laser",1.6),
          mkTrap(2320,698,120,22,"laser",1.3),
        ],
      }),

      // Level 6 — Precision Sync: Tight timing, no mistakes
      () => ({
        name: "Precision Sync",
        objective: "Cross moving platforms and press both sync pads to open the final door.",
        spawn1: {x:120,y:640}, spawn2:{x:200,y:640},
        bounds: {minX:-300, maxX:4200, minY:-900, maxY:1400},
        platforms: [
          rect(-300,720,5200,80),
          rect(700,610,160,22),
          rect(980,520,160,22),
          rect(1260,430,160,22),
          rect(1540,340,160,22),
          rect(1820,430,160,22),
          rect(2100,520,160,22),
          rect(2380,610,160,22),
          rect(2740,640,200,22),
          rect(3400,640,200,22),
        ],
        entities: [
          mkMovingPlatform(820,560,150,18,"y", 560, 420, 220),
          mkMovingPlatform(2060,560,150,18,"y", 560, 420, 260),
          mkSwitch(2780,612,120,22,"sync2","Boy Pad","boy","timedSync"),
          mkSwitch(3440,612,120,22,"sync2","Girl Pad","girl","timedSync"),
          mkDoor(3120,560,70,160,"sync2"),
          mkHint(300,632,420,70,"Level 6: sync pads within 0.22s. Movement is instant—no sliding. Time it."),
          mkGoal(3920,590,120,130),
        ],
        hazards: [
          mkTrap(1620,698,120,22,"spike",0),
          mkTrap(1660,698,120,22,"spike",0),
          mkTrap(3200,698,120,22,"laser",1.0),
        ],
      }),

      // Level 7 — Final Trial: Multi-stage puzzle using all mechanics
      () => ({
        name: "Final Trial",
        objective: "Use control pad + ladder + timed sync + trap disable. Finish together.",
        spawn1: {x:120,y:640}, spawn2:{x:200,y:640},
        bounds: {minX:-400, maxX:5200, minY:-1200, maxY:1500},
        platforms: [
          rect(-400,720,6200,80),
          rect(520,650,240,22),
          rect(920,600,220,22),
          rect(1280,540,220,22),
          rect(1640,480,220,22),
          rect(2000,420,220,22),
          rect(2460,360,260,22),
          rect(2920,360,260,22),
          rect(3340,440,260,22),
          rect(3720,520,260,22),
          rect(4120,600,260,22),
          rect(4520,640,300,22),
          rect(4700,360,240,22),
          rect(4980,240,240,22),
        ],
        entities: [
          mkSwitch(540,622,160,22,"mover2","Control","boy","hold"),
          mkDoor(800,660,60,60,"mover2"),
          mkMovingPlatform(1800,610,170,20,"x", 1760, 2420, 280),

          mkLadder(3100,200,80,520),

          mkSwitch(3720,492,120,22,"trapOff2","Disable","both","hold"),
          mkDoor(4000,580,70,140,"trapOff2"),

          mkSwitch(4720,332,120,22,"finalDoor","Boy Pad","boy","timedSync"),
          mkSwitch(5000,212,120,22,"finalDoor","Girl Pad","girl","timedSync"),
          mkDoor(5140,160,70,180,"finalDoor"),

          mkHint(260,632,520,70,"Final: Boy controls mover. Ladder climb. Hold Disable to cross. Then sync pads to open the last door."),
          mkGoal(5400,130,120,130),
        ],
        hazards: [
          mkTrap(2220,698,120,22,"laser",1.2),
          mkTrap(3460,698,120,22,"laser",1.4),
          mkTrap(3860,698,120,22,"spike",0),
          mkTrap(3900,698,120,22,"spike",0),
          mkTrap(4300,698,120,22,"laser",1.1),
        ],
      }),
    ];

    // ---------- Players ----------
    function makePlayer(kind){
      const isBoy = kind === "boy";
      return {
        kind,
        name: isBoy ? "Boy" : "Girl",
        x: 0, y: 0,
        w: 44, h: 62,
        vx: 0, vy: 0,
        grounded: false,
        onLadder: false,
        justJumped: false,
        facing: 1,
        state: "Idle",
        failTimer: 0,
        animT: 0,
        color1: isBoy ? getCss("--boy") : getCss("--girl"),
        color2: isBoy ? getCss("--boy2") : getCss("--girl2"),
        // input snapshot
        wantX: 0,
        wantClimb: 0,
        wantJump: false,
      };
    }
    function getCss(varName){
      return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    }

    const boy = makePlayer("boy");
    const girl = makePlayer("girl");

    // ---------- Level runtime ----------
    let world = null; // current level data
    let timeAcc = 0;
    let lastFrame = now();

    function resetPlayers(spawn1, spawn2){
      boy.x = spawn1.x; boy.y = spawn1.y - boy.h;
      girl.x = spawn2.x; girl.y = spawn2.y - girl.h;
      for (const p of [boy,girl]){
        p.vx = 0; p.vy = 0; p.grounded = false; p.onLadder = false;
        p.failTimer = 0; p.animT = 0; p.state = "Idle"; p.facing = 1;
      }
    }

    function loadLevel(i){
      state.levelIndex = i;
      world = levels[i]();
      resetPlayers(world.spawn1, world.spawn2);
      state.levelTime = 0;
      state.msg = "";
      state.msgTimer = 0;
      // reset entity state
      for (const e of (world.entities||[])){
        if (e.type === "door"){ e.open=false; e.anim=0; }
        if (e.type === "switch"){ e.pressed=false; e.anim=0; e.lastPress=-1; }
        if (e.type === "mplat"){ e.t=0; e.dir=1; e.vx=0; e.vy=0; }
        if (e.type === "goal"){ e.anim=0; }
        if (e.type === "trap"){ e.t=0; e.on=true; e.anim=0; }
        if (e.type === "hint"){ e.seen=false; }
      }
      updateHUD();
      srStatus.textContent = `Loaded Level ${i+1}: ${world.name}`;
    }

    // ---------- Game flow ----------
    function showOverlay(title, desc, startLabel="Start", howLabel="Level Rules"){
      screenTitle.textContent = title;
      screenDesc.textContent = desc;
      btnStart.textContent = startLabel;
      btnHow.textContent = howLabel;
      overlay.style.display = "flex";
    }
    function hideOverlay(){
      overlay.style.display = "none";
    }

    btnHow.addEventListener('click', () => {
      if (!world){
        showOverlay("Together Trials — Level Rules",
          "Rules: Doors open only while required switches are held. Timed sync pads must be pressed within a small window. Level completes only when both stand inside the green goal together.\n\nTip: Your movement is instant—release to stop. Coordinate, don’t rush.");
        btnStart.textContent = "Back";
        btnStart.onclick = () => { btnStart.onclick = null; showStart(); };
        return;
      }
      const idx = state.levelIndex+1;
      showOverlay(`Level ${idx}/7 — ${world.name}`, world.objective, "Back", "—");
      btnHow.style.display = "none";
      btnStart.onclick = () => { btnStart.onclick = null; btnHow.style.display = ""; hideOverlay(); };
    });

    function showStart(){
      state.mode = "start";
      showOverlay("Together Trials — Co-op Platformer",
        "Two players, one keyboard. Movement is precise: press to move, release to stop. Doors open only when you cooperate.\n\nGoal: Clear 7 co-op levels together.",
        "Start", "Level Rules");
    }

    btnStart.addEventListener('click', async () => {
      try { await getAudio().resume(); } catch {}
      if (state.mode === "start"){
        state.deaths = 0;
        loadLevel(0);
        hideOverlay();
        state.mode = "play";
        chord([392, 523, 659], 0.10, 0.06);
        return;
      }
      // when used as "Restart" / "Next"
      if (state.mode === "gameOver"){
        loadLevel(state.levelIndex);
        hideOverlay();
        state.mode = "play";
        chord([330, 440, 523], 0.11, 0.06);
        return;
      }
      if (state.mode === "levelComplete"){
        const next = state.levelIndex + 1;
        if (next >= levels.length){
          showStart();
          return;
        }
        loadLevel(next);
        hideOverlay();
        state.mode = "play";
        chord([440, 554, 659], 0.10, 0.06);
        return;
      }
    });

    function gameOver(reason="Oops!"){
      state.mode = "gameOver";
      state.deaths++;
      updateHUD();
      beep("sawtooth", 140, 0.10, 0.10);
      beep("triangle", 110, 0.14, 0.08);
      showOverlay("Game Over", `${reason}\n\nRestart the level and try again together.`, "Restart", "Level Rules");
    }

    function levelComplete(){
      state.mode = "levelComplete";
      chord([523, 659, 784], 0.14, 0.07);
      const idx = state.levelIndex+1;
      const isLast = idx >= levels.length;
      showOverlay(isLast ? "You did it!" : `Level ${idx} Complete!`,
        isLast ? `All 7 trials cleared.\n\nTotal deaths: ${state.deaths}` : world.objective,
        isLast ? "Back to Title" : "Next Level",
        "Level Rules");
    }

    // ---------- HUD ----------
    function updateHUD(){
      lvlLabel.textContent = `Level ${state.levelIndex+1}/7`;
      deathLabel.textContent = String(state.deaths);
      if (world) objectiveEl.textContent = world.objective.replace(/\s+/g,' ').trim();
    }

    // ---------- Mechanics helpers ----------
    function playerRect(p){ return {x:p.x, y:p.y, w:p.w, h:p.h}; }

    function computeInputs(){
      // Boy: A/D move, W/S ladder climb; Jump: Space
      // Girl: ArrowLeft/Right move, ArrowUp/Down ladder; Jump: Ctrl
      const bHoriz = lastWins(["KeyA","KeyD"]);
      const gHoriz = lastWins(["ArrowLeft","ArrowRight"]);

      boy.wantX = bHoriz === "KeyA" ? -1 : bHoriz === "KeyD" ? 1 : 0;
      girl.wantX = gHoriz === "ArrowLeft" ? -1 : gHoriz === "ArrowRight" ? 1 : 0;

      // Ladder climb intent
      boy.wantClimb = (keyDown.has("KeyW") ? -1 : 0) + (keyDown.has("KeyS") ? 1 : 0);
      girl.wantClimb = (keyDown.has("ArrowUp") ? -1 : 0) + (keyDown.has("ArrowDown") ? 1 : 0);

      boy.wantJump = keyDown.has("Space");
      girl.wantJump = keyDown.has("ControlLeft") || keyDown.has("ControlRight");
    }

    function setPlayerState(p){
      if (p.failTimer > 0){ p.state = "Fail"; return; }
      if (p.onLadder){
        if (p.wantClimb !== 0) p.state = "Climb";
        else p.state = "Idle";
        return;
      }
      if (!p.grounded){
        p.state = p.vy < 0 ? "Jump" : "Fall";
        return;
      }
      if (p.wantX !== 0) p.state = "Run";
      else p.state = "Idle";
    }

    // ---------- Collision ----------
    function resolveCollisions(p, solids){
      // Axis-separable, deterministic
      p.grounded = false;

      // X move
      p.x += p.vx * PHYS.step;
      let pr = playerRect(p);
      for (const s of solids){
        if (!aabbIntersect(pr, s)) continue;
        if (p.vx > 0){
          p.x = s.x - p.w;
        } else if (p.vx < 0){
          p.x = s.x + s.w;
        }
        pr = playerRect(p);
      }

      // Y move
      p.y += p.vy * PHYS.step;
      pr = playerRect(p);
      for (const s of solids){
        if (!aabbIntersect(pr, s)) continue;
        if (p.vy > 0){
          // falling onto platform
          p.y = s.y - p.h;
          p.vy = 0;
          p.grounded = true;
        } else if (p.vy < 0){
          // hitting ceiling
          p.y = s.y + s.h;
          p.vy = 0;
        }
        pr = playerRect(p);
      }
    }

    function buildSolids(){
      const solids = [];
      // static platforms
      for (const r of (world.platforms||[])) solids.push(r);
      // doors (if closed)
      for (const e of (world.entities||[])){
        if (e.type === "door" && !e.open) solids.push(rect(e.x,e.y,e.w,e.h));
        if (e.type === "mplat") solids.push(rect(e.x,e.y,e.w,e.h));
      }
      return solids;
    }

    function pointInRect(px,py,r){
      return px >= r.x && px <= r.x+r.w && py >= r.y && py <= r.y+r.h;
    }

    function onLadder(p){
      for (const e of (world.entities||[])){
        if (e.type !== "ladder") continue;
        const pr = playerRect(p);
        const overlap = aabbIntersect(pr, e);
        if (overlap) return e;
      }
      return null;
    }

    // ---------- Co-op logic ----------
    function switchPressedBy(sw, p){
      const pr = playerRect(p);
      const foot = rect(pr.x+6, pr.y+pr.h-6, pr.w-12, 10);
      return aabbIntersect(foot, sw);
    }

    function updateEntities(dt){
      const ents = world.entities || [];
      const hazards = world.hazards || [];
      // moving platforms
      for (const e of ents){
        if (e.type !== "mplat") continue;
        const prevX = e.x, prevY = e.y;
        // Some movers are enabled only when a linked door is open, but we can also link to a switch id:
        // We'll enable mover if there is a switch with same id pressed OR a door with same id open
        let enabled = true;
        const hasControl = ents.some(x => x.type==="switch" && x.id==="mover" || x.id==="mover2");
        // But keep them always active unless their id is "mover"/"mover2": those require control switch pressed.
        const requiresControl = (ents.some(x => x.type==="switch" && x.id==="mover") && (world.entities||[]).some(x => x.type==="switch" && x.id==="mover") && true) || (ents.some(x => x.type==="switch" && x.id==="mover2") && true);
        if (requiresControl){
          // enabled if any switch matching door id is pressed (hold)
          const anyPressed = ents.some(x => x.type==="switch" && x.id === (x.id) && (x.id==="mover" || x.id==="mover2") && x.pressed);
          enabled = anyPressed;
        }
        if (!enabled){
          e.vx = 0; e.vy = 0;
          continue;
        }
        e.t += dt;
        const target = e.axis === "x" ? (e.dir>0 ? e.b : e.a) : (e.dir>0 ? e.b : e.a);
        const pos = e.axis === "x" ? e.x : e.y;
        const delta = e.speed * dt;
        let next = pos + (e.dir * delta);
        if ((e.dir>0 && next >= target) || (e.dir<0 && next <= target)){
          next = target;
          e.dir *= -1;
        }
        if (e.axis === "x"){ e.x = next; e.vx = (e.x - prevX) / dt; e.vy = 0; }
        else { e.y = next; e.vy = (e.y - prevY) / dt; e.vx = 0; }

        // carry players standing on it (precise, no inertia drift; directly apply platform delta when grounded)
        const dx = e.x - prevX, dy = e.y - prevY;
        for (const p of [boy,girl]){
          const pr = playerRect(p);
          const feet = rect(pr.x+6, pr.y+pr.h-2, pr.w-12, 6);
          const top = rect(e.x, e.y-2, e.w, 6);
          const onTop = aabbIntersect(feet, top) && p.vy >= 0;
          if (onTop){
            p.x += dx;
            p.y += dy;
          }
        }
      }

      // traps cycle
      for (const t of hazards){
        if (t.type !== "trap") continue;
        if (t.cycle > 0){
          t.t += dt;
          const phase = (t.t % t.cycle) / t.cycle;
          // on for 60%, off for 40%
          t.on = phase < 0.60;
        } else {
          t.on = true;
        }
        t.anim = lerp(t.anim, t.on ? 1 : 0, 1 - Math.pow(0.001, dt));
      }

      // switches, doors, goals, hints
      // First, evaluate switches pressed states (hold resets if anyone leaves)
      for (const sw of ents){
        if (sw.type !== "switch") continue;
        const b = switchPressedBy(sw, boy);
        const g = switchPressedBy(sw, girl);
        let pressed = false;

        if (sw.kind === "hold"){
          if (sw.require === "both") pressed = b && g;
          else if (sw.require === "boy") pressed = b;
          else if (sw.require === "girl") pressed = g;
        } else if (sw.kind === "timedSync"){
          // individually pressed by required player; door opens only if both pads (same id) are pressed within window
          const t = performance.now()/1000;
          if (sw.require === "boy" && b){ sw.lastPress = t; }
          if (sw.require === "girl" && g){ sw.lastPress = t; }
          // "pressed" here means currently held by required player
          if (sw.require === "boy") pressed = b;
          if (sw.require === "girl") pressed = g;
          // If not held, reset lastPress quickly to enforce "pads reset if anyone leaves"
          if (!pressed) sw.lastPress = -1;
        }

        const was = sw.pressed;
        sw.pressed = pressed;
        sw.anim = lerp(sw.anim, sw.pressed ? 1 : 0, 1 - Math.pow(0.001, dt));
        if (!was && sw.pressed){
          beep("square", 720, 0.05, 0.06);
          sw._flash = 1;
        }
        if (sw._flash) sw._flash = Math.max(0, sw._flash - dt*3.5);
      }

      // Door logic
      for (const d of ents){
        if (d.type !== "door") continue;
        const related = ents.filter(x => x.type==="switch" && x.id===d.id);
        let open = false;

        if (related.length){
          const kinds = new Set(related.map(s=>s.kind));
          if (kinds.has("hold")){
            // for "hold" group: all switches with that id must be pressed simultaneously
            open = related.every(s => s.kind !== "hold" ? true : s.pressed);
          }
          if (kinds.has("timedSync")){
            // for timed sync: require two pads with same id both held AND within window
            const pads = related.filter(s=>s.kind==="timedSync");
            if (pads.length >= 2){
              const allHeld = pads.every(s=>s.pressed);
              if (allHeld){
                const times = pads.map(s=>s.lastPress).filter(v=>v>=0);
                if (times.length === pads.length){
                  const span = Math.max(...times) - Math.min(...times);
                  const windowSec = (d.id === "sync2") ? 0.22 : 0.25;
                  open = span <= windowSec;
                }
              }
            }
          }
        } else {
          open = false;
        }

        // Special: "trapOff"/"trapOff2" doors open when switch pressed (both required)
        const prev = d.open;
        d.open = open;
        d.anim = lerp(d.anim, d.open ? 1 : 0, 1 - Math.pow(0.001, dt));
        if (d.open && !prev) beep("triangle", 520, 0.07, 0.06);
        if (!d.open && prev) beep("triangle", 260, 0.06, 0.04);
      }

      // Trap disable groups: if switch with id trapOff/trapOff2 pressed => hazards off
      const trapOff = ents.some(e => e.type==="switch" && (e.id==="trapOff" || e.id==="trapOff2") && e.pressed);
      if (trapOff){
        for (const t of hazards){
          if (t.kind === "laser") { t.on = false; t.anim = lerp(t.anim, 0, 1 - Math.pow(0.001, dt)); }
        }
      }

      // Hints mark seen
      for (const h of ents){
        if (h.type !== "hint") continue;
        if (h.seen) continue;
        const hr = rect(h.x,h.y,h.w,h.h);
        if (aabbIntersect(playerRect(boy), hr) || aabbIntersect(playerRect(girl), hr)){
          h.seen = true;
          state.msg = h.text;
          state.msgTimer = 4.5;
          srStatus.textContent = h.text;
          beep("sine", 880, 0.04, 0.05);
        }
      }

      // Goals animation
      for (const g of ents){
        if (g.type !== "goal") continue;
        g.anim += dt;
      }
    }

    function checkHazards(){
      const hazards = world.hazards || [];
      for (const p of [boy,girl]){
        const pr = playerRect(p);
        // fall out
        if (p.y > world.bounds.maxY + 400) return `${p.name} fell.`;
        // traps
        for (const t of hazards){
          if (t.type !== "trap") continue;
          if (!t.on) continue;
          if (aabbIntersect(pr, t)){
            return `${p.name} hit a trap.`;
          }
        }
      }
      return null;
    }

    function checkGoal(){
      const goal = (world.entities||[]).find(e=>e.type==="goal");
      if (!goal) return false;
      const gr = rect(goal.x, goal.y, goal.w, goal.h);
      const inBoy = aabbIntersect(playerRect(boy), gr);
      const inGirl = aabbIntersect(playerRect(girl), gr);
      return inBoy && inGirl;
    }

    // ---------- Player update ----------
    function updatePlayer(p, dt){
      // Determine ladder status
      const ladder = onLadder(p);
      p.onLadder = !!ladder;

      // Horizontal velocity: deterministic, instant, last key wins. No inertia drift.
      const speed = p.onLadder ? PHYS.moveV : (p.grounded ? PHYS.moveV : PHYS.airMoveV);
      p.vx = p.wantX * speed;
      if (p.wantX !== 0) p.facing = p.wantX;

      // Ladder vertical control (W/S or Up/Down). Jump only when grounded.
      if (p.onLadder){
        // snap slightly inside ladder to reduce edge jitter
        p.vy = p.wantClimb * 260;
        // allow stepping off ladder by moving sideways: still deterministic
        if (p.wantJump && p.grounded){
          p.vy = -PHYS.jumpV;
          p.grounded = false;
          p.onLadder = false;
          beep("square", 520, 0.05, 0.05);
        }
      } else {
        // Jump: only when grounded; affects vertical only
        if (p.wantJump && p.grounded){
          p.vy = -PHYS.jumpV;
          p.grounded = false;
          p.justJumped = true;
          beep("square", 520, 0.05, 0.06);
        } else {
          p.justJumped = false;
        }
        // Gravity
        p.vy = clamp(p.vy + PHYS.g * PHYS.step, -99999, PHYS.maxFall);
      }

      // Collisions with solids
      const solids = buildSolids();
      resolveCollisions(p, solids);

      // If on ladder and not overlapping anymore, release ladder
      if (p.onLadder && !onLadder(p)) p.onLadder = false;

      // Clamp to bounds (horizontal)
      p.x = clamp(p.x, world.bounds.minX, world.bounds.maxX - p.w);

      // Failing face timer
      if (p.failTimer > 0) p.failTimer = Math.max(0, p.failTimer - dt);

      // Animation time
      p.animT += dt * (p.state === "Run" ? 7 : (p.onLadder && p.wantClimb !== 0 ? 6 : 2));
      setPlayerState(p);
    }

    // ---------- Rendering ----------
    function drawRoundedRect(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y, x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x, y+h, r);
      ctx.arcTo(x, y+h, x, y, r);
      ctx.arcTo(x, y, x+w, y, r);
      ctx.closePath();
      ctx.fill();
    }

    function drawWorld(){
      const w = window.innerWidth, h = window.innerHeight;

      // Background
      ctx.fillStyle = "#0b1020";
      ctx.fillRect(0,0,w,h);

      // Subtle parallax dots
      const t = performance.now()/1000;
      ctx.save();
      ctx.globalAlpha = 0.35;
      for (let i=0;i<70;i++){
        const px = (i*137.5 + (t*18)) % (w+120) - 60;
        const py = (i*83.2 + (t*9)) % (h+120) - 60;
        const r = (i%5===0)?2.2:1.4;
        ctx.fillStyle = i%3===0 ? "rgba(147,197,253,.35)" : i%3===1 ? "rgba(244,114,182,.25)" : "rgba(255,255,255,.18)";
        ctx.beginPath(); ctx.arc(px,py,r,0,Math.PI*2); ctx.fill();
      }
      ctx.restore();

      // Camera transform
      ctx.save();
      ctx.translate(w/2, h/2);
      ctx.scale(cam.z, cam.z);
      ctx.translate(-cam.x, -cam.y);

      // Floor/platforms
      for (const r of (world.platforms||[])){
        // platform style
        const grad = ctx.createLinearGradient(r.x, r.y, r.x, r.y+r.h);
        grad.addColorStop(0, "rgba(55,65,81,1)");
        grad.addColorStop(1, "rgba(17,24,39,1)");
        ctx.fillStyle = grad;
        drawRoundedRect(r.x, r.y, r.w, r.h, 10);
        ctx.strokeStyle = "rgba(255,255,255,.07)";
        ctx.lineWidth = 2;
        ctx.strokeRect(r.x+1, r.y+1, r.w-2, r.h-2);
      }

      // Entities
      for (const e of (world.entities||[])){
        if (e.type === "ladder"){
          ctx.save();
          ctx.fillStyle = "rgba(148,163,184,.10)";
          drawRoundedRect(e.x, e.y, e.w, e.h, 10);
          ctx.globalAlpha = 0.8;
          ctx.strokeStyle = "rgba(226,232,240,.28)";
          ctx.lineWidth = 3;
          for (let yy=e.y+18; yy<e.y+e.h-10; yy+=28){
            ctx.beginPath();
            ctx.moveTo(e.x+10, yy);
            ctx.lineTo(e.x+e.w-10, yy);
            ctx.stroke();
          }
          ctx.restore();
        } else if (e.type === "mplat"){
          ctx.save();
          const pulse = 0.5 + 0.5*Math.sin((performance.now()/1000)*3);
          ctx.fillStyle = `rgba(59,130,246,${0.12+0.08*pulse})`;
          drawRoundedRect(e.x-3, e.y-6, e.w+6, e.h+10, 10);
          const grad = ctx.createLinearGradient(e.x, e.y, e.x, e.y+e.h);
          grad.addColorStop(0, "rgba(30,41,59,1)");
          grad.addColorStop(1, "rgba(15,23,42,1)");
          ctx.fillStyle = grad;
          drawRoundedRect(e.x, e.y, e.w, e.h, 10);
          ctx.strokeStyle = "rgba(147,197,253,.28)";
          ctx.lineWidth = 2;
          ctx.strokeRect(e.x+1, e.y+1, e.w-2, e.h-2);
          ctx.restore();
        } else if (e.type === "switch"){
          ctx.save();
          const base = e.pressed ? "rgba(34,197,94,0.90)" : "rgba(34,197,94,0.28)";
          const glow = e.pressed ? 0.35 : 0.10;
          const flash = (e._flash||0);
          ctx.fillStyle = `rgba(34,197,94,${glow + 0.25*flash})`;
          drawRoundedRect(e.x-5, e.y-10, e.w+10, e.h+16, 10);
          ctx.fillStyle = base;
          drawRoundedRect(e.x, e.y, e.w, e.h, 10);
          ctx.strokeStyle = "rgba(255,255,255,.16)";
          ctx.lineWidth = 2;
          ctx.strokeRect(e.x+1, e.y+1, e.w-2, e.h-2);
          ctx.fillStyle = "rgba(0,0,0,.35)";
          ctx.font = "12px ui-sans-serif,system-ui";
          ctx.textAlign = "center";
          ctx.fillText(e.label || "Switch", e.x+e.w/2, e.y-8);
          ctx.restore();
        } else if (e.type === "door"){
          ctx.save();
          const openT = e.anim;
          const closedAlpha = 1 - openT;
          // frame
          ctx.fillStyle = "rgba(245,158,11,.18)";
          drawRoundedRect(e.x-6, e.y-6, e.w+12, e.h+12, 12);
          // door panel (slides down when opening)
          const slide = lerp(0, e.h+8, openT);
          ctx.globalAlpha = closedAlpha;
          const grad = ctx.createLinearGradient(e.x, e.y, e.x, e.y+e.h);
          grad.addColorStop(0, "rgba(245,158,11,.95)");
          grad.addColorStop(1, "rgba(180,83,9,.95)");
          ctx.fillStyle = grad;
          drawRoundedRect(e.x, e.y+slide, e.w, Math.max(0, e.h-slide), 12);
          ctx.globalAlpha = 1;
          ctx.strokeStyle = "rgba(255,255,255,.12)";
          ctx.lineWidth = 2;
          ctx.strokeRect(e.x+1, e.y+1, e.w-2, e.h-2);
          ctx.restore();
        } else if (e.type === "goal"){
          ctx.save();
          const tt = e.anim;
          const pulse = 0.5 + 0.5*Math.sin(tt*3);
          ctx.fillStyle = `rgba(34,197,94,${0.14+0.12*pulse})`;
          drawRoundedRect(e.x-10, e.y-10, e.w+20, e.h+20, 16);
          ctx.fillStyle = "rgba(34,197,94,.16)";
          drawRoundedRect(e.x, e.y, e.w, e.h, 16);
          ctx.strokeStyle = "rgba(34,197,94,.45)";
          ctx.lineWidth = 3;
          ctx.strokeRect(e.x+2, e.y+2, e.w-4, e.h-4);
          ctx.fillStyle = "rgba(0,0,0,.40)";
          ctx.font = "12px ui-sans-serif,system-ui";
          ctx.textAlign = "center";
          ctx.fillText("GOAL (both)", e.x+e.w/2, e.y-10);
          ctx.restore();
        } else if (e.type === "hint" && !e.seen){
          ctx.save();
          ctx.globalAlpha = 0.7;
          ctx.fillStyle = "rgba(255,255,255,.06)";
          drawRoundedRect(e.x, e.y, e.w, e.h, 14);
          ctx.strokeStyle = "rgba(255,255,255,.10)";
          ctx.lineWidth = 2; ctx.strokeRect(e.x+1,e.y+1,e.w-2,e.h-2);
          ctx.fillStyle = "rgba(229,231,235,.75)";
          ctx.font = "12px ui-sans-serif,system-ui";
          ctx.textAlign = "left";
          wrapText(e.text, e.x+12, e.y+24, e.w-22, 14);
          ctx.restore();
        }
      }

      // Hazards
      for (const t of (world.hazards||[])){
        if (t.type !== "trap") continue;
        ctx.save();
        const a = t.on ? 1 : 0.15;
        ctx.globalAlpha = lerp(0.15, 1, t.anim);
        if (t.kind === "spike"){
          ctx.fillStyle = `rgba(239,68,68,${0.95*a})`;
          for (let x=t.x; x<t.x+t.w; x+=18){
            ctx.beginPath();
            ctx.moveTo(x, t.y+t.h);
            ctx.lineTo(x+9, t.y);
            ctx.lineTo(x+18, t.y+t.h);
            ctx.closePath();
            ctx.fill();
          }
        } else {
          // laser tile
          ctx.fillStyle = `rgba(239,68,68,${0.22*a})`;
          drawRoundedRect(t.x, t.y, t.w, t.h, 10);
          const pulse = 0.5+0.5*Math.sin((performance.now()/1000)*10);
          ctx.fillStyle = `rgba(239,68,68,${(0.65+0.25*pulse)*a})`;
          ctx.fillRect(t.x+6, t.y+5, t.w-12, t.h-10);
          ctx.strokeStyle = `rgba(255,255,255,${0.12*a})`;
          ctx.lineWidth = 2;
          ctx.strokeRect(t.x+1,t.y+1,t.w-2,t.h-2);
        }
        ctx.restore();
      }

      // Players
      drawPlayer(boy);
      drawPlayer(girl);

      // Co-op tether line (visual cue if separated)
      const dx = (boy.x+boy.w/2) - (girl.x+girl.w/2);
      const dy = (boy.y+boy.h/2) - (girl.y+girl.h/2);
      const dist = Math.hypot(dx,dy);
      ctx.save();
      ctx.globalAlpha = clamp((dist-260)/420, 0, 0.65);
      ctx.strokeStyle = "rgba(148,163,184,.55)";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(boy.x+boy.w/2, boy.y+boy.h/2);
      ctx.lineTo(girl.x+girl.w/2, girl.y+girl.h/2);
      ctx.stroke();
      ctx.restore();

      ctx.restore(); // camera

      // Message toast
      if (state.msgTimer > 0){
        const pad = 12;
        const text = state.msg;
        ctx.save();
        ctx.globalAlpha = clamp(state.msgTimer/0.25, 0, 1);
        ctx.font = "13px ui-sans-serif,system-ui";
        const lines = measureWrap(text, Math.min(560, w-34), 16);
        const tw = Math.min(560, w-34);
        const th = 18 + lines.length*16 + 14;
        const x = (w - (tw+pad*2))/2;
        const y = 72;
        ctx.fillStyle = "rgba(2,6,23,.70)";
        roundRectScreen(x, y, tw+pad*2, th, 14);
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,.10)";
        ctx.lineWidth = 1.5;
        ctx.stroke();
        ctx.fillStyle = "rgba(229,231,235,.86)";
        let yy = y + 24;
        for (const ln of lines){
          ctx.fillText(ln, x+pad, yy);
          yy += 16;
        }
        ctx.restore();
      }

      // Mobile hint
      if (w < 720 && state.mode === "play"){
        ctx.save();
        ctx.globalAlpha = 0.55;
        ctx.font = "12px ui-sans-serif,system-ui";
        ctx.fillStyle = "rgba(229,231,235,.80)";
        ctx.textAlign = "center";
        ctx.fillText("Keyboard only: A/D + Space (Boy), ←/→ + Ctrl (Girl).", w/2, h-18);
        ctx.restore();
      }
    }

    function wrapText(text, x, y, maxWidth, lineHeight){
      const words = (text||"").split(/\s+/);
      let line = "";
      for (let n=0;n<words.length;n++){
        const test = line + words[n] + " ";
        const w = ctx.measureText(test).width;
        if (w > maxWidth && n > 0){
          ctx.fillText(line, x, y);
          line = words[n] + " ";
          y += lineHeight;
        } else {
          line = test;
        }
      }
      ctx.fillText(line, x, y);
    }

    function measureWrap(text, maxWidth, lineHeight){
      ctx.save();
      ctx.font = "13px ui-sans-serif,system-ui";
      const words = (text||"").split(/\s+/);
      const lines = [];
      let line = "";
      for (let i=0;i<words.length;i++){
        const test = line ? (line + " " + words[i]) : words[i];
        if (ctx.measureText(test).width > maxWidth && line){
          lines.push(line);
          line = words[i];
        } else line = test;
      }
      if (line) lines.push(line);
      ctx.restore();
      return lines;
    }

    function roundRectScreen(x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y, x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x, y+h, r);
      ctx.arcTo(x, y+h, x, y, r);
      ctx.arcTo(x, y, x+w, y, r);
      ctx.closePath();
    }

    function drawPlayer(p){
      const x = p.x, y = p.y, w = p.w, h = p.h;
      const headR = 18;
      const bodyH = 30;
      const t = p.animT;
      const bob = (p.state==="Run") ? Math.sin(t)*2.2 : (p.state==="Idle" ? Math.sin(t*0.7)*1.2 : 0);
      const lean = (p.state==="Run") ? p.facing*2 : 0;

      ctx.save();
      // shadow
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "black";
      ctx.beginPath();
      ctx.ellipse(x+w/2, y+h+6, 18, 6, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // body
      ctx.translate(0, bob);
      // legs
      const legSwing = (p.state==="Run") ? Math.sin(t*2.2)*8 : 0;
      ctx.fillStyle = "rgba(15,23,42,.95)";
      drawRoundedRect(x+10, y+h-18, 10, 18, 6);
      drawRoundedRect(x+w-20, y+h-18, 10, 18, 6);

      // sneakers
      ctx.fillStyle = "rgba(226,232,240,.92)";
      drawRoundedRect(x+6, y+h-6, 16, 8, 5);
      drawRoundedRect(x+w-22, y+h-6, 16, 8, 5);

      // pants
      ctx.fillStyle = "rgba(31,41,55,.92)";
      drawRoundedRect(x+8, y+h-34, w-16, 20, 10);

      // torso
      const torsoY = y + 26;
      const torsoW = w-10;
      const torsoX = x + 5 + lean*0.2;
      ctx.fillStyle = p.color1;
      drawRoundedRect(torsoX, torsoY, torsoW, bodyH, 14);

      // hoodie/jacket details
      ctx.fillStyle = "rgba(255,255,255,.13)";
      drawRoundedRect(torsoX+6, torsoY+8, torsoW-12, 10, 10);

      // arms
      ctx.fillStyle = p.color1;
      const armY = torsoY + 12;
      const armSwing = (p.state==="Run") ? Math.sin(t*2.2 + Math.PI)*7 : 0;
      drawRoundedRect(torsoX-6, armY + armSwing*0.25, 12, 20, 8);
      drawRoundedRect(torsoX+torsoW-6, armY - armSwing*0.25, 12, 20, 8);

      // head
      const hx = x + w/2 + lean*0.3;
      const hy = y + 14;
      ctx.fillStyle = "rgba(255,228,214,.98)";
      ctx.beginPath();
      ctx.arc(hx, hy, headR, 0, Math.PI*2);
      ctx.fill();

      // hair
      ctx.fillStyle = p.kind==="boy" ? "rgba(30,41,59,.95)" : "rgba(63,35,106,.95)";
      ctx.beginPath();
      ctx.arc(hx, hy-6, headR, Math.PI, 0);
      ctx.closePath();
      ctx.fill();
      if (p.kind==="girl"){
        // ponytail
        ctx.beginPath();
        ctx.ellipse(hx + p.facing*16, hy+2, 9, 12, 0.2*p.facing, 0, Math.PI*2);
        ctx.fill();
      }

      // face expressions
      const face = getFace(p);
      const eyeY = hy - 2;
      const eyeXOff = 6;
      ctx.save();
      ctx.translate(hx, hy);
      // eyes whites
      ctx.fillStyle = "rgba(255,255,255,.92)";
      ctx.beginPath();
      ctx.ellipse(-eyeXOff, eyeY-hy, 4.2, 3.4, 0, 0, Math.PI*2);
      ctx.ellipse( eyeXOff, eyeY-hy, 4.2, 3.4, 0, 0, Math.PI*2);
      ctx.fill();
      // pupils
      ctx.fillStyle = "rgba(15,23,42,.95)";
      const look = (p.state==="Run") ? p.facing*1.8 : 0.4*p.facing;
      ctx.beginPath();
      ctx.arc(-eyeXOff + look, (eyeY-hy)+0.2, face.eyeR, 0, Math.PI*2);
      ctx.arc( eyeXOff + look, (eyeY-hy)+0.2, face.eyeR, 0, Math.PI*2);
      ctx.fill();
      // eyebrows
      ctx.strokeStyle = "rgba(15,23,42,.65)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-12, -10 + face.browY);
      ctx.lineTo(-3, -12 + face.browY - face.browTilt*p.facing);
      ctx.moveTo(12, -10 + face.browY);
      ctx.lineTo(3, -12 + face.browY + face.browTilt*p.facing);
      ctx.stroke();
      // mouth
      ctx.strokeStyle = "rgba(15,23,42,.75)";
      ctx.lineWidth = 2.2;
      ctx.beginPath();
      const my = 9 + face.mouthY;
      if (face.mouth === "smile"){
        ctx.arc(0, my, 7, 0.15*Math.PI, 0.85*Math.PI);
      } else if (face.mouth === "focus"){
        ctx.moveTo(-6, my+2); ctx.lineTo(6, my+1);
      } else if (face.mouth === "surprise"){
        ctx.beginPath();
        ctx.ellipse(0, my+2, 4.2, 5.2, 0, 0, Math.PI*2);
      } else if (face.mouth === "frown"){
        ctx.arc(0, my+9, 8, 1.15*Math.PI, 1.85*Math.PI);
      }
      ctx.stroke();
      ctx.restore();

      // icon aura when on ladder
      if (p.onLadder){
        ctx.save();
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = p.color2;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(hx, hy, headR+7, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      }

      ctx.restore();
    }

    function getFace(p){
      // states: Idle/Run/Jump/Fall/Climb/Fail
      if (p.state === "Fail") return { eyeR: 2.0, browY: 3, browTilt: 3, mouth:"frown", mouthY: 2 };
      if (p.state === "Run") return { eyeR: 2.2, browY: 0, browTilt: 5, mouth:"focus", mouthY: 2 };
      if (p.state === "Jump" || p.state === "Fall") return { eyeR: 2.6, browY: -1, browTilt: 6, mouth:(p.kind==="girl" ? "focus" : "surprise"), mouthY: 1 };
      if (p.state === "Climb") return { eyeR: 2.1, browY: 1, browTilt: 4, mouth:"focus", mouthY: 2 };
      // Idle
      return { eyeR: 2.1, browY: 2, browTilt: 2, mouth:(p.kind==="girl" ? "smile" : "smile"), mouthY: 2 };
    }

    // ---------- Camera update ----------
    function updateCamera(dt){
      const w = window.innerWidth, h = window.innerHeight;
      const p1 = {x: boy.x + boy.w/2, y: boy.y + boy.h/2};
      const p2 = {x: girl.x + girl.w/2, y: girl.y + girl.h/2};

      const minX = Math.min(p1.x, p2.x), maxX = Math.max(p1.x, p2.x);
      const minY = Math.min(p1.y, p2.y), maxY = Math.max(p1.y, p2.y);
      const cx = (minX + maxX)/2;
      const cy = (minY + maxY)/2;

      const dx = (maxX - minX) + 520;
      const dy = (maxY - minY) + 380;

      // desired zoom: fit dx/dy to screen
      const zx = w / dx;
      const zy = h / dy;
      let targetZ = clamp(Math.min(zx, zy), 0.55, 1.35);

      cam.targetZ = targetZ;
      cam.z = lerp(cam.z, cam.targetZ, 1 - Math.pow(0.001, dt));
      cam.x = lerp(cam.x, cx, 1 - Math.pow(0.001, dt));
      cam.y = lerp(cam.y, cy, 1 - Math.pow(0.001, dt));

      // keep camera within some bounds
      cam.x = clamp(cam.x, world.bounds.minX + w/(2*cam.z), world.bounds.maxX - w/(2*cam.z));
      cam.y = clamp(cam.y, world.bounds.minY + h/(2*cam.z), world.bounds.maxY - h/(2*cam.z));
    }

    // ---------- Main loop ----------
    function tick(){
      const t = now();
      let dt = (t - lastFrame) / 1000;
      lastFrame = t;
      dt = clamp(dt, 0, 0.05);

      if (state.mode === "play" && world){
        state.levelTime += dt;
        state.totalTime += dt;
        timeLabel.textContent = `${state.levelTime.toFixed(1)}s`;

        if (state.msgTimer > 0) state.msgTimer = Math.max(0, state.msgTimer - dt);

        computeInputs();

        timeAcc += dt;
        while (timeAcc >= PHYS.step){
          // entities update at fixed step (deterministic)
          updateEntities(PHYS.step);

          // update players
          updatePlayer(boy, PHYS.step);
          updatePlayer(girl, PHYS.step);

          // set HUD state labels
          boyStateEl.textContent = boy.state;
          girlStateEl.textContent = girl.state;

          // hazards / goal check
          const hazardHit = checkHazards();
          if (hazardHit){
            boy.failTimer = 0.55; girl.failTimer = 0.55;
            state.mode = "freeze";
            // quick freeze then game over
            setTimeout(() => {
              if (state.mode === "freeze") gameOver(hazardHit);
            }, 120);
            break;
          }
          if (checkGoal()){
            state.mode = "freeze";
            setTimeout(() => {
              if (state.mode === "freeze") levelComplete();
            }, 120);
            break;
          }

          timeAcc -= PHYS.step;
        }

        updateCamera(dt);
      } else {
        // idle render camera
        if (world) updateCamera(dt);
      }

      drawWorld();
      requestAnimationFrame(tick);
    }

    // ---------- Keyboard pause & quick restart ----------
    window.addEventListener('keydown', (e) => {
      if (e.code === "KeyR" && state.mode === "play"){
        beep("triangle", 220, 0.06, 0.04);
        loadLevel(state.levelIndex);
      }
      if (e.code === "Escape"){
        if (state.mode === "play"){
          state.mode = "pause";
          showOverlay("Paused", "Press Resume to continue. (Inputs are deterministic—no inertia.)", "Resume", "Level Rules");
          btnStart.onclick = () => { btnStart.onclick = null; hideOverlay(); state.mode="play"; };
        } else if (state.mode === "pause"){
          hideOverlay(); state.mode="play";
        }
      }
    });

    // ---------- Init ----------
    showStart();
    // build a default world for background rendering on title
    world = levels[0]();
    resetPlayers(world.spawn1, world.spawn2);
    updateHUD();

    requestAnimationFrame(() => {
      lastFrame = now();
      tick();
    });
  })();
  </script>
</body>
</html>