<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <title>Together Apart — 2P Coop Platformer</title>
  <style>
    :root{
      --bg0:#081018;
      --bg1:#0c1a28;
      --ui:#eaf2ff;
      --muted:#a7b7d6;
      --good:#63ffa7;
      --warn:#ffd56a;
      --bad:#ff6b88;
      --boy:#4aa3ff;
      --boy2:#1f6fe0;
      --girl:#c35cff;
      --girl2:#ff4aa8;
      --ink:#06101a;
      --panel: rgba(8,16,24,.72);
      --panel2: rgba(8,16,24,.90);
      --stroke: rgba(234,242,255,.14);
      --shadow: rgba(0,0,0,.35);
    }

    html,body{
      margin:0;
      height:100%;
      background: radial-gradient(1200px 800px at 30% 20%, #102742 0%, var(--bg0) 55%, #050a10 100%);
      overflow:hidden;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color: var(--ui);
      user-select:none;
      -webkit-user-select:none;
      -webkit-tap-highlight-color: transparent;
    }

    #wrap{
      position:fixed;
      inset:0;
      display:grid;
      grid-template-rows: 1fr;
    }

    canvas{
      width:100%;
      height:100%;
      display:block;
      background:
        radial-gradient(900px 600px at 70% 15%, rgba(92,166,255,.18) 0%, rgba(0,0,0,0) 60%),
        radial-gradient(900px 600px at 20% 10%, rgba(216,99,255,.14) 0%, rgba(0,0,0,0) 60%),
        linear-gradient(180deg, #071018 0%, #050b11 100%);
    }

    #hud{
      position:fixed;
      inset: 12px 12px auto 12px;
      display:flex;
      gap:10px;
      align-items:flex-start;
      pointer-events:none;
      flex-wrap:wrap;
    }

    .pill{
      pointer-events:none;
      background: var(--panel);
      border:1px solid var(--stroke);
      box-shadow: 0 12px 26px var(--shadow);
      border-radius: 14px;
      padding: 10px 12px;
      backdrop-filter: blur(8px);
    }

    #hud .pill{
      display:flex;
      gap:10px;
      align-items:center;
      min-height: 38px;
    }

    .k{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width: 22px;
      height: 22px;
      padding: 0 6px;
      border-radius: 8px;
      border: 1px solid rgba(234,242,255,.20);
      background: rgba(255,255,255,.06);
      font-weight: 700;
      letter-spacing: .2px;
      color: var(--ui);
      box-shadow: inset 0 -2px 0 rgba(0,0,0,.25);
      font-size: 12px;
    }

    .sep{ width:1px; height:18px; background: rgba(234,242,255,.12); }

    #centerOverlay{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
      padding: 18px;
    }

    .card{
      pointer-events:none;
      width:min(820px, 94vw);
      background: linear-gradient(180deg, rgba(8,16,24,.88), rgba(8,16,24,.72));
      border:1px solid rgba(234,242,255,.16);
      box-shadow: 0 18px 50px rgba(0,0,0,.5);
      border-radius: 18px;
      padding: 18px 18px 14px;
      backdrop-filter: blur(10px);
    }

    .title{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:14px;
      flex-wrap:wrap;
      margin-bottom: 12px;
    }
    .title h1{
      margin:0;
      font-size: clamp(22px, 4vw, 34px);
      letter-spacing: .2px;
      line-height:1.05;
    }
    .subtitle{
      color: var(--muted);
      font-size: 13px;
      line-height:1.3;
      max-width: 520px;
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    @media (max-width: 700px){
      .grid{ grid-template-columns: 1fr; }
    }

    .panel{
      border-radius: 14px;
      padding: 12px;
      border:1px solid rgba(234,242,255,.14);
      background: rgba(255,255,255,.05);
    }

    .panel h3{
      margin: 0 0 6px;
      font-size: 13px;
      letter-spacing:.2px;
      color: rgba(234,242,255,.92);
    }

    .panel p, .panel li{
      margin: 0;
      color: rgba(234,242,255,.78);
      font-size: 12.5px;
      line-height:1.35;
    }
    .panel ul{ margin: 6px 0 0; padding-left: 18px; }
    .panel li{ margin: 4px 0; }

    .ctaRow{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      margin-top: 12px;
      flex-wrap:wrap;
    }
    .cta{
      pointer-events:none;
      display:flex;
      align-items:center;
      gap:10px;
      font-weight:800;
      color: rgba(234,242,255,.96);
      letter-spacing:.15px;
    }
    .note{
      color: rgba(234,242,255,.70);
      font-size: 12px;
    }

    #toast{
      position:fixed;
      left:50%;
      transform: translateX(-50%);
      bottom: 14px;
      background: rgba(8,16,24,.72);
      border:1px solid rgba(234,242,255,.14);
      padding: 10px 12px;
      border-radius: 14px;
      box-shadow: 0 12px 28px rgba(0,0,0,.45);
      color: rgba(234,242,255,.90);
      font-size: 12.5px;
      pointer-events:none;
      opacity:0;
      transition: opacity .18s ease, transform .18s ease;
      backdrop-filter: blur(10px);
      max-width: min(760px, 92vw);
      text-align:center;
      line-height:1.25;
    }
    #toast.show{
      opacity:1;
      transform: translateX(-50%) translateY(-4px);
    }

    /* tiny corner help for mobile users that lack keyboard */
    #kbHint{
      position:fixed;
      right: 12px;
      bottom: 12px;
      width:min(360px, 48vw);
      max-width: 420px;
      pointer-events:none;
      opacity:.0;
      transition: opacity .25s ease;
      display:none;
    }
    @media (hover:none){
      #kbHint{ display:block; opacity:.85; }
    }
    #kbHint .pill{ font-size:12px; color: rgba(234,242,255,.78); }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="game" aria-label="Together Apart coop platformer"></canvas>

  <div id="hud" aria-hidden="true">
    <div class="pill" id="hudLeft">
      <strong id="hudLevel">Level 1/7</strong>
      <span class="sep"></span>
      <span id="hudTime">0:00.00</span>
      <span class="sep"></span>
      <span>Deaths: <strong id="hudDeaths">0</strong></span>
      <span class="sep"></span>
      <span>Best: <strong id="hudBest">—</strong></span>
    </div>
    <div class="pill" id="hudRight">
      <span style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
        <span style="display:inline-flex; align-items:center; gap:6px;">
          <span style="width:10px; height:10px; border-radius:999px; background:var(--boy); box-shadow:0 0 0 3px rgba(74,163,255,.18)"></span>
          Boy:
          <span class="k">A</span><span class="k">D</span><span class="k">W</span><span class="k">S</span>
        </span>
        <span class="sep"></span>
        <span style="display:inline-flex; align-items:center; gap:6px;">
          <span style="width:10px; height:10px; border-radius:999px; background:var(--girl); box-shadow:0 0 0 3px rgba(195,92,255,.18)"></span>
          Girl:
          <span class="k">←</span><span class="k">→</span><span class="k">↑</span><span class="k">↓</span>
        </span>
        <span class="sep"></span>
        <span><span class="k">R</span> Restart</span>
        <span><span class="k">Enter</span> Continue</span>
      </span>
    </div>
  </div>

  <div id="centerOverlay" aria-hidden="true">
    <div class="card" id="overlayCard" style="display:none;"></div>
  </div>

  <div id="toast" aria-hidden="true"></div>

  <div id="kbHint" aria-hidden="true">
    <div class="pill">
      This game needs a keyboard (two players, one keyboard). If you're on mobile, connect a keyboard to play.
    </div>
  </div>
</div>

<script>
(() => {
  // ===== Canvas / DPR =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  function resize() {
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const w = Math.floor(canvas.clientWidth * DPR);
    const h = Math.floor(canvas.clientHeight * DPR);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w; canvas.height = h;
    }
  }
  window.addEventListener('resize', resize, { passive:true });
  resize();

  // ===== UI =====
  const hudLevel = document.getElementById('hudLevel');
  const hudTime = document.getElementById('hudTime');
  const hudDeaths = document.getElementById('hudDeaths');
  const hudBest = document.getElementById('hudBest');
  const overlayCard = document.getElementById('overlayCard');
  const toast = document.getElementById('toast');

  function fmtTime(ms){
    if (!isFinite(ms)) return '—';
    const t = Math.max(0, ms);
    const s = Math.floor(t/1000);
    const m = Math.floor(s/60);
    const ss = (s%60).toString().padStart(2,'0');
    const cs = Math.floor((t%1000)/10).toString().padStart(2,'0');
    return `${m}:${ss}.${cs}`;
  }

  let toastTimer = 0;
  function showToast(msg, ms=2200){
    toast.textContent = msg;
    toast.classList.add('show');
    toastTimer = ms;
  }
  function hideToast(){
    toast.classList.remove('show');
  }

  // ===== Audio (Web Audio API) =====
  let audioCtx = null;
  function ensureAudio(){
    if (audioCtx) return;
    try{
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    } catch(e){ audioCtx = null; }
  }
  function beep({freq=440, dur=0.07, type='sine', gain=0.06, glideTo=null}={}){
    if (!audioCtx) return;
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t0);
    if (glideTo) o.frequency.exponentialRampToValueAtTime(glideTo, t0 + Math.max(0.01, dur));
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(gain, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(t0);
    o.stop(t0 + dur + 0.02);
  }
  function sfx(name){
    ensureAudio();
    if (!audioCtx) return;
    if (name === 'jump') beep({freq:560, dur:0.06, type:'square', gain:0.045, glideTo:760});
    if (name === 'land') beep({freq:160, dur:0.05, type:'sine', gain:0.03, glideTo:120});
    if (name === 'switch') beep({freq:420, dur:0.07, type:'triangle', gain:0.05, glideTo:360});
    if (name === 'door') beep({freq:220, dur:0.10, type:'sawtooth', gain:0.035, glideTo:120});
    if (name === 'hurt') beep({freq:110, dur:0.12, type:'square', gain:0.05, glideTo:70});
    if (name === 'goal') beep({freq:660, dur:0.12, type:'triangle', gain:0.05, glideTo:990});
    if (name === 'win') { beep({freq:523.25, dur:0.12, type:'triangle', gain:0.045, glideTo:783.99}); setTimeout(()=>beep({freq:659.25, dur:0.12, type:'triangle', gain:0.045, glideTo:987.77}), 90); setTimeout(()=>beep({freq:783.99, dur:0.15, type:'triangle', gain:0.05, glideTo:1174.66}), 180); }
  }

  // ===== Deterministic input (last key press wins) =====
  const keysDown = new Map(); // code -> bool
  const keyStamp = new Map(); // code -> increasing integer stamp
  let stampCounter = 1;

  const JUST_PRESSED = new Set();
  const JUST_RELEASED = new Set();

  function setKey(code, down){
    if (down){
      if (!keysDown.get(code)){
        keysDown.set(code, true);
        keyStamp.set(code, ++stampCounter);
        JUST_PRESSED.add(code);
      }
    } else {
      if (keysDown.get(code)){
        keysDown.set(code, false);
        JUST_RELEASED.add(code);
      }
    }
  }

  window.addEventListener('keydown', (e)=>{
    ensureAudio();
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
    setKey(e.code, true);
  }, { passive:false });

  window.addEventListener('keyup', (e)=>{
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
    setKey(e.code, false);
  }, { passive:false });

  function isDown(code){ return !!keysDown.get(code); }
  function wasPressed(code){ return JUST_PRESSED.has(code); }

  function dirFromKeys(leftCode, rightCode){
    const l = isDown(leftCode), r = isDown(rightCode);
    if (l && r){
      const sl = keyStamp.get(leftCode) || 0;
      const sr = keyStamp.get(rightCode) || 0;
      return (sr > sl) ? 1 : -1; // last press wins deterministically
    }
    if (l) return -1;
    if (r) return 1;
    return 0;
  }

  // ===== Geometry helpers =====
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function rectsOverlap(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }
  function pointInRect(px,py,r){
    return px>=r.x && px<=r.x+r.w && py>=r.y && py<=r.y+r.h;
  }

  // ===== Game constants =====
  const PHYS = {
    gravity: 1900,
    moveSpeed: 260,
    jumpVel: 720,
    climbSpeed: 210,
    maxFall: 1400,
    stepEps: 0.0001
  };

  // ===== World objects =====
  class Player {
    constructor(id, name, palette, controls){
      this.id = id;
      this.name = name;
      this.palette = palette;
      this.controls = controls;

      this.w = 28;
      this.h = 48;

      this.x = 0; this.y = 0;
      this.vy = 0;
      this.grounded = false;
      this.onLadder = false;
      this.facing = 1;
      this.state = 'idle';
      this.animT = 0;
      this.failT = 0;
      this.celebrateT = 0;

      this.lastGroundY = 0;
      this.coyote = 0;
      this._landedThisStep = false;
      this._jumpedThisStep = false;
    }

    rect(){
      return { x:this.x, y:this.y, w:this.w, h:this.h };
    }

    setSpawn(sp){
      this.x = sp.x; this.y = sp.y;
      this.vy = 0;
      this.grounded = false;
      this.onLadder = false;
      this.failT = 0;
      this.celebrateT = 0;
      this.animT = 0;
    }
  }

  // Moving platform types:
  // {x,y,w,h, mode:'auto'|'controlled', ax, bx, speed, t, vx, vy, controller:'boy'|'girl', bounds:{min,max}}
  // Crates: {x,y,w,h,vx} - deterministic push only.
  // Ladders: {x,y,w,h}
  // Switches: {x,y,w,h, kind:'plate'|'dualPlate'|'timedDual'|'holdPlate', who:'both'|'boy'|'girl', id, label, hold:boolean, timer:number, maxTimer:number, active:boolean}
  // Doors: {x,y,w,h, id, requires:[switchIds], mode:'and', open:false, nearW:120}
  // Traps: {x,y,w,h, id, disabledBy:[switchId], active:true, kind:'spike'|'crusher'}
  // Levers: {x,y,w,h, id, requiresHoldMs, heldBy:{boy:ms,girl:ms}, active:false}
  // Goals: {x,y,w,h}

  function makeLevel1(){
    const solids = [
      {x:-200, y:540, w:2400, h:200, kind:'ground'},
      {x:240, y:450, w:140, h:18, kind:'platform'},
      {x:460, y:390, w:160, h:18, kind:'platform'},
      {x:720, y:340, w:150, h:18, kind:'platform'},
      {x:980, y:470, w:160, h:18, kind:'platform'},
      {x:1160, y:420, w:160, h:18, kind:'platform'},
      {x:1320, y:360, w:180, h:18, kind:'platform'},
      {x:1520, y:520, w:280, h:18, kind:'platform'}
    ];
    const crates = [
      {x:140, y:512, w:34, h:28, vx:0},
    ];
    const switches = [
      {id:'L1_plate', x:620, y:522, w:64, h:18, kind:'dualPlate', who:'both', active:false, label:'Stand together', timer:0, maxTimer:0}
    ];
    const doors = [
      {id:'L1_door', x:860, y:468, w:34, h:72, requires:['L1_plate'], mode:'and', open:false, nearW:170}
    ];
    const goal = {x:1780, y:468, w:58, h:72};
    return {
      name: 'Basic Coordination',
      hint: 'Stand TOGETHER on the glowing plate to unlock the door. Doors only open when both are present.',
      bounds: {x0:-100, x1:2000, y0:0, y1:700},
      spawns: [{x:40,y:492},{x:90,y:492}],
      solids, crates,
      moving: [],
      ladders: [],
      switches, doors,
      traps: [],
      levers: [],
      goal,
      failY: 760
    };
  }

  function makeLevel2(){
    const solids = [
      {x:-200, y:540, w:2800, h:200, kind:'ground'},
      {x:260, y:470, w:160, h:18, kind:'platform'},
      {x:520, y:420, w:160, h:18, kind:'platform'},
      {x:780, y:370, w:160, h:18, kind:'platform'},
      {x:1040, y:420, w:160, h:18, kind:'platform'},
      {x:1300, y:470, w:160, h:18, kind:'platform'},
      {x:1560, y:420, w:160, h:18, kind:'platform'},
      {x:1820, y:370, w:160, h:18, kind:'platform'},
      {x:2100, y:540, w:320, h:18, kind:'platform'}
    ];
    const switches = [
      {id:'L2_boyBtn', x:360, y:522, w:60, h:18, kind:'plate', who:'boy', active:false, label:'Boy button', timer:0, maxTimer:0},
      {id:'L2_girlBtn', x:1500, y:522, w:60, h:18, kind:'plate', who:'girl', active:false, label:'Girl button', timer:0, maxTimer:0},
      {id:'L2_timedDual', x:0, y:0, w:0, h:0, kind:'timedDual', who:'both', active:false, label:'Simultaneous', timer:0, maxTimer:4600, // open time
       refs:['L2_boyBtn','L2_girlBtn']}
    ];
    const doors = [
      {id:'L2_door', x:1960, y:468, w:34, h:72, requires:['L2_timedDual'], mode:'and', open:false, nearW:180}
    ];
    const goal = {x:2320, y:468, w:58, h:72};
    return {
      name:'Timed Movement',
      hint:'Split up: each presses their own button. The door opens only if you press them at the same time—then regroup at the door together!',
      bounds:{x0:-120, x1:2500, y0:0, y1:700},
      spawns:[{x:40,y:492},{x:90,y:492}],
      solids, crates:[],
      moving:[],
      ladders:[],
      switches, doors,
      traps:[],
      levers:[],
      goal,
      failY: 760
    };
  }

  function makeLevel3(){
    const solids = [
      {x:-200, y:540, w:3200, h:200, kind:'ground'},
      {x:300, y:470, w:140, h:18, kind:'platform'},
      {x:560, y:430, w:140, h:18, kind:'platform'},
      {x:820, y:400, w:140, h:18, kind:'platform'},
      // big gap for moving platform
      {x:1460, y:450, w:160, h:18, kind:'platform'},
      {x:1760, y:410, w:160, h:18, kind:'platform'},
      {x:2060, y:370, w:160, h:18, kind:'platform'},
      {x:2380, y:540, w:420, h:18, kind:'platform'}
    ];
    const moving = [
      {id:'L3_mover', x:1080, y:500, w:120, h:16, mode:'controlled', vx:0, vy:0,
       bounds:{min:980, max:1320}, controller:'boy'}
    ];
    const switches = [
      {id:'L3_plate', x:2240, y:522, w:64, h:18, kind:'dualPlate', who:'both', active:false, label:'Together', timer:0, maxTimer:0}
    ];
    const doors = [
      {id:'L3_door', x:2520, y:468, w:34, h:72, requires:['L3_plate'], mode:'and', open:false, nearW:180}
    ];
    const goal = {x:2760, y:468, w:58, h:72};
    return {
      name:'Moving Platforms',
      hint:'Boy controls the moving platform from the control pad. Girl uses it to cross. Then stand together to unlock the exit.',
      bounds:{x0:-120, x1:2920, y0:0, y1:760},
      spawns:[{x:40,y:492},{x:90,y:492}],
      solids, crates:[],
      moving,
      ladders:[],
      switches, doors,
      traps:[],
      levers:[],
      controlPads:[
        {id:'L3_pad', x:980, y:522, w:90, h:18, who:'boy', label:'Control pad'}
      ],
      goal,
      failY: 820
    };
  }

  function makeLevel4(){
    const solids = [
      {x:-260, y:620, w:2200, h:260, kind:'ground'},
      // left tower
      {x:120, y:540, w:160, h:18, kind:'platform'},
      {x:120, y:460, w:160, h:18, kind:'platform'},
      {x:120, y:380, w:160, h:18, kind:'platform'},
      {x:120, y:300, w:160, h:18, kind:'platform'},
      // mid ledges
      {x:520, y:520, w:170, h:18, kind:'platform'},
      {x:760, y:450, w:170, h:18, kind:'platform'},
      {x:1000, y:380, w:170, h:18, kind:'platform'},
      {x:1240, y:310, w:170, h:18, kind:'platform'},
      {x:1480, y:240, w:220, h:18, kind:'platform'},
      // top shelf
      {x:1600, y:160, w:260, h:18, kind:'platform'},
      {x:1600, y:620, w:300, h:18, kind:'platform'}
    ];
    const ladders = [
      {id:'L4_ladder1', x:320, y:300, w:60, h:260},
      {id:'L4_ladder2', x:860, y:240, w:60, h:260},
      {id:'L4_ladder3', x:1400, y:160, w:60, h:260}
    ];
    const switches = [
      {id:'L4_extendA', x:520, y:602, w:66, h:18, kind:'plate', who:'boy', active:false, label:'Extend bridge', timer:0, maxTimer:0},
      {id:'L4_extendB', x:1120, y:292, w:66, h:18, kind:'plate', who:'girl', active:false, label:'Extend bridge', timer:0, maxTimer:0},
      {id:'L4_together', x:1700, y:602, w:70, h:18, kind:'dualPlate', who:'both', active:false, label:'Together', timer:0, maxTimer:0}
    ];
    const doors = [
      {id:'L4_door', x:1780, y:548, w:34, h:72, requires:['L4_together'], mode:'and', open:false, nearW:200}
    ];
    const goal = {x:1860, y:548, w:58, h:72};
    return {
      name:'Vertical Ascent',
      hint:'Climb ladders (W/↑ to climb up, S/↓ down). Step on your color switch to extend a bridge for the other.',
      bounds:{x0:-120, x1:1960, y0:-40, y1:900},
      spawns:[{x:40,y:572},{x:90,y:572}],
      solids, crates:[],
      moving:[],
      ladders,
      switches, doors,
      traps:[],
      levers:[],
      // dynamic solids controlled by switches
      bridges:[
        {id:'L4_bridgeA', x:700, y:520, w:130, h:14, enabledBy:'L4_extendA'},
        {id:'L4_bridgeB', x:1360, y:310, w:130, h:14, enabledBy:'L4_extendB'}
      ],
      goal,
      failY: 980
    };
  }

  function makeLevel5(){
    const solids = [
      {x:-220, y:560, w:3200, h:260, kind:'ground'},
      {x:220, y:480, w:180, h:18, kind:'platform'},
      {x:520, y:440, w:180, h:18, kind:'platform'},
      {x:820, y:400, w:180, h:18, kind:'platform'},
      {x:1120, y:480, w:220, h:18, kind:'platform'},
      {x:1460, y:520, w:220, h:18, kind:'platform'},
      {x:1820, y:480, w:220, h:18, kind:'platform'},
      {x:2140, y:440, w:240, h:18, kind:'platform'},
      {x:2520, y:560, w:420, h:18, kind:'platform'}
    ];
    const switches = [
      {id:'L5_disable1', x:560, y:542, w:66, h:18, kind:'holdPlate', who:'boy', active:false, label:'Hold to disable traps', timer:0, maxTimer:0},
      {id:'L5_disable2', x:1860, y:462, w:66, h:18, kind:'holdPlate', who:'girl', active:false, label:'Hold to disable traps', timer:0, maxTimer:0},
      {id:'L5_together', x:2680, y:542, w:70, h:18, kind:'dualPlate', who:'both', active:false, label:'Together', timer:0, maxTimer:0}
    ];
    const traps = [
      {id:'L5_spikes1', x:700, y:542, w:330, h:18, kind:'spike', disabledBy:['L5_disable1'], active:true},
      {id:'L5_spikes2', x:1960, y:542, w:280, h:18, kind:'spike', disabledBy:['L5_disable2'], active:true}
    ];
    const doors = [
      {id:'L5_door', x:2840, y:488, w:34, h:72, requires:['L5_together'], mode:'and', open:false, nearW:200}
    ];
    const goal = {x:2920, y:488, w:58, h:72};
    return {
      name:'Split Responsibility',
      hint:'One holds the switch to disable spikes while the other advances. Switches reset instantly if you step off.',
      bounds:{x0:-120, x1:3100, y0:0, y1:900},
      spawns:[{x:40,y:512},{x:90,y:512}],
      solids, crates:[],
      moving:[],
      ladders:[],
      switches, doors,
      traps,
      levers:[],
      goal,
      failY: 940
    };
  }

  function makeLevel6(){
    const solids = [
      {x:-220, y:560, w:3600, h:280, kind:'ground'},
      {x:240, y:480, w:160, h:18, kind:'platform'},
      {x:520, y:420, w:160, h:18, kind:'platform'},
      {x:800, y:360, w:160, h:18, kind:'platform'},
      {x:1100, y:420, w:160, h:18, kind:'platform'},
      {x:1400, y:480, w:160, h:18, kind:'platform'},
      {x:1720, y:520, w:220, h:18, kind:'platform'},
      {x:2080, y:480, w:220, h:18, kind:'platform'},
      {x:2460, y:440, w:220, h:18, kind:'platform'},
      {x:2880, y:560, w:520, h:18, kind:'platform'}
    ];
    const switches = [
      {id:'L6_left', x:700, y:542, w:64, h:18, kind:'plate', who:'boy', active:false, label:'Left switch', timer:0, maxTimer:0},
      {id:'L6_right', x:2560, y:422, w:64, h:18, kind:'plate', who:'girl', active:false, label:'Right switch', timer:0, maxTimer:0},
      {id:'L6_sync', x:0,y:0,w:0,h:0, kind:'dualPlate', who:'both', active:false, label:'Sync', timer:0, maxTimer:0, refs:['L6_left','L6_right']}
    ];
    const doors = [
      {id:'L6_door', x:3000, y:488, w:34, h:72, requires:['L6_sync'], mode:'and', open:false, nearW:220}
    ];
    const traps = [
      // "crushers" that pulse on/off using cycle (handled by update)
      {id:'L6_crush1', x:980, y:542, w:120, h:18, kind:'crusher', disabledBy:[], active:true, cycle:{t:0, period:1.1, duty:0.55, phase:0.00}},
      {id:'L6_crush2', x:1540, y:542, w:120, h:18, kind:'crusher', disabledBy:[], active:true, cycle:{t:0, period:0.95, duty:0.50, phase:0.25}},
      {id:'L6_crush3', x:2260, y:542, w:140, h:18, kind:'crusher', disabledBy:[], active:true, cycle:{t:0, period:1.25, duty:0.52, phase:0.55}}
    ];
    const goal = {x:3300, y:488, w:58, h:72};
    return {
      name:'Precision Sync',
      hint:'Cross the pulsing crushers with tight timing. Then press your switches and keep them held together to open the door.',
      bounds:{x0:-120, x1:3520, y0:0, y1:980},
      spawns:[{x:40,y:512},{x:90,y:512}],
      solids, crates:[],
      moving:[],
      ladders:[],
      switches, doors,
      traps,
      levers:[],
      goal,
      failY: 980
    };
  }

  function makeLevel7(){
    const solids = [
      {x:-240, y:580, w:4200, h:320, kind:'ground'},
      {x:260, y:500, w:180, h:18, kind:'platform'},
      {x:520, y:440, w:160, h:18, kind:'platform'},
      {x:780, y:400, w:160, h:18, kind:'platform'},
      // stage 1 gap
      {x:1100, y:540, w:220, h:18, kind:'platform'},
      {x:1400, y:480, w:180, h:18, kind:'platform'},
      // stage 2 vertical room base
      {x:1700, y:540, w:220, h:18, kind:'platform'},
      {x:1980, y:500, w:220, h:18, kind:'platform'},
      {x:2260, y:460, w:220, h:18, kind:'platform'},
      {x:2540, y:420, w:220, h:18, kind:'platform'},
      {x:2820, y:380, w:220, h:18, kind:'platform'},
      {x:3100, y:340, w:220, h:18, kind:'platform'},
      {x:3380, y:300, w:240, h:18, kind:'platform'},
      {x:3660, y:580, w:420, h:18, kind:'platform'}
    ];
    const moving = [
      {id:'L7_mover', x:960, y:530, w:120, h:16, mode:'controlled', vx:0, vy:0,
       bounds:{min:880, max:1160}, controller:'girl'}
    ];
    const ladders = [
      {id:'L7_ladder', x:2100, y:320, w:60, h:240}
    ];
    const switches = [
      {id:'L7_disable', x:1780, y:522, w:66, h:18, kind:'holdPlate', who:'boy', active:false, label:'Disable spikes', timer:0, maxTimer:0},
      {id:'L7_btnA', x:2920, y:362, w:60, h:18, kind:'plate', who:'boy', active:false, label:'Boy sync', timer:0, maxTimer:0},
      {id:'L7_btnB', x:3240, y:322, w:60, h:18, kind:'plate', who:'girl', active:false, label:'Girl sync', timer:0, maxTimer:0},
      {id:'L7_timedDual', x:0,y:0,w:0,h:0, kind:'timedDual', who:'both', active:false, label:'Timed sync', timer:0, maxTimer:3600, refs:['L7_btnA','L7_btnB']},
      {id:'L7_together', x:3780, y:562, w:72, h:18, kind:'dualPlate', who:'both', active:false, label:'Together', timer:0, maxTimer:0}
    ];
    const levers = [
      {id:'L7_lever', x:2420, y:442, w:60, h:38, requiresHoldMs:700, heldBy:{boy:0,girl:0}, active:false, label:'Hold DOWN together'}
    ];
    const traps = [
      {id:'L7_spikes', x:1860, y:562, w:380, h:18, kind:'spike', disabledBy:['L7_disable'], active:true},
      {id:'L7_crush', x:2620, y:402, w:120, h:18, kind:'crusher', disabledBy:[], active:true, cycle:{t:0, period:1.05, duty:0.50, phase:0.15}}
    ];
    const doors = [
      {id:'L7_door1', x:2140, y:468, w:34, h:112, requires:['L7_lever'], mode:'and', open:false, nearW:200},
      {id:'L7_door2', x:3520, y:228, w:34, h:112, requires:['L7_timedDual'], mode:'and', open:false, nearW:220},
      {id:'L7_doorFinal', x:3920, y:508, w:34, h:72, requires:['L7_together'], mode:'and', open:false, nearW:240}
    ];
    const goal = {x:4020, y:508, w:58, h:72};
    return {
      name:'Final Trial',
      hint:'Use everything: girl controls the mover, boy disables spikes, climb the ladder, hold DOWN together on the lever, then timed sync switches and finish together!',
      bounds:{x0:-140, x1:4240, y0:0, y1:1060},
      spawns:[{x:40,y:532},{x:90,y:532}],
      solids, crates:[],
      moving,
      ladders,
      switches, doors,
      traps,
      levers,
      controlPads:[
        {id:'L7_pad', x:880, y:562, w:92, h:18, who:'girl', label:'Control pad'}
      ],
      goal,
      failY: 1060
    };
  }

  const LEVELS = [makeLevel1, makeLevel2, makeLevel3, makeLevel4, makeLevel5, makeLevel6, makeLevel7];

  // ===== Game state =====
  const BOY = new Player(0, 'Boy', {primary:'#4aa3ff', secondary:'#1f6fe0', accent:'#9cd2ff'}, {
    left:'KeyA', right:'KeyD', up:'KeyW', down:'KeyS'
  });
  const GIRL = new Player(1, 'Girl', {primary:'#c35cff', secondary:'#ff4aa8', accent:'#ffd1f2'}, {
    left:'ArrowLeft', right:'ArrowRight', up:'ArrowUp', down:'ArrowDown'
  });
  const players = [BOY, GIRL];

  let levelIndex = 0;
  let level = null;

  let state = 'start'; // start, intro, playing, levelComplete, gameOver, victory
  let levelTimeMs = 0;
  let deaths = 0;
  let totalDeaths = 0;

  const BEST_KEY = 'togetherApart_bestTimes_v1';
  let bestTimes = {};
  try{ bestTimes = JSON.parse(localStorage.getItem(BEST_KEY) || '{}') || {}; } catch(e){ bestTimes = {}; }

  function bestFor(idx){
    const k = `L${idx+1}`;
    return bestTimes[k];
  }
  function setBest(idx, ms){
    const k = `L${idx+1}`;
    const cur = bestTimes[k];
    if (!cur || ms < cur){
      bestTimes[k] = ms;
      try{ localStorage.setItem(BEST_KEY, JSON.stringify(bestTimes)); } catch(e){}
      return true;
    }
    return false;
  }

  // ===== Camera =====
  const cam = {
    x: 0, y: 0,
    scale: 1.1,
    tx: 0, ty: 0,
    shakeT: 0,
    shakeMag: 0
  };

  function shake(mag=6, t=0.18){
    cam.shakeMag = Math.max(cam.shakeMag, mag);
    cam.shakeT = Math.max(cam.shakeT, t);
  }

  // ===== Level load/reset =====
  function loadLevel(idx){
    levelIndex = clamp(idx, 0, LEVELS.length-1);
    level = LEVELS[levelIndex]();
    levelTimeMs = 0;
    deaths = 0;

    BOY.setSpawn(level.spawns[0]);
    GIRL.setSpawn(level.spawns[1]);

    cam.x = (BOY.x + GIRL.x) / 2;
    cam.y = (BOY.y + GIRL.y) / 2;
    cam.scale = 1.1;

    // reset timers
    if (level.switches) for (const s of level.switches){ s.active=false; s.timer=s.timer||0; }
    if (level.levers) for (const l of level.levers){ l.active=false; l.heldBy={boy:0,girl:0}; }
    if (level.moving) for (const m of level.moving){ m.vx=0; m.vy=0; m.t=0; }
    if (level.traps) for (const t of level.traps){ if (t.cycle) t.cycle.t=0; }

    hudLevel.textContent = `Level ${levelIndex+1}/7`;
    hudDeaths.textContent = deaths.toString();
    const b = bestFor(levelIndex);
    hudBest.textContent = b ? fmtTime(b) : '—';

    state = 'intro';
    renderOverlayIntro();
    showToast(level.hint, 2600);
  }

  function restartLevel(){
    totalDeaths += deaths;
    loadLevel(levelIndex);
    sfx('hurt');
  }

  function nextLevel(){
    if (levelIndex >= LEVELS.length-1){
      state = 'victory';
      renderOverlayVictory();
      sfx('win');
    } else {
      loadLevel(levelIndex+1);
    }
  }

  // ===== Overlays =====
  function setOverlay(html){
    overlayCard.innerHTML = html;
    overlayCard.style.display = 'block';
  }
  function hideOverlay(){
    overlayCard.style.display = 'none';
  }

  function renderOverlayStart(){
    const html = `
      <div class="title">
        <div>
          <h1>Together Apart</h1>
          <div class="subtitle">A 2-player cooperative platformer inspired by <em>It Takes Two</em> — designed for two players on one keyboard. Movement is snappy: press = move instantly, release = stop instantly.</div>
        </div>
        <div class="subtitle">7 Levels • Shared Camera • Real teamwork</div>
      </div>

      <div class="grid">
        <div class="panel">
          <h3>Player 1 — Boy (Blue)</h3>
          <p><span class="k">A</span> left, <span class="k">D</span> right, <span class="k">W</span> jump / climb up, <span class="k">S</span> crouch / press / climb down</p>
          <ul>
            <li>Doors open only when both are present.</li>
            <li>Some switches reset the instant you step off.</li>
          </ul>
        </div>
        <div class="panel">
          <h3>Player 2 — Girl (Purple)</h3>
          <p><span class="k">←</span> left, <span class="k">→</span> right, <span class="k">↑</span> jump / climb up, <span class="k">↓</span> crouch / press / climb down</p>
          <ul>
            <li>Simultaneous actions matter (timed doors / synced switches).</li>
            <li>Finish a level only when both reach the goal together.</li>
          </ul>
        </div>
      </div>

      <div class="ctaRow">
        <div class="cta"><span class="k">Enter</span> Start</div>
        <div class="note"><span class="k">R</span> restart • <span class="k">Esc</span> pause</div>
      </div>
    `;
    setOverlay(html);
  }

  function renderOverlayIntro(){
    const b = bestFor(levelIndex);
    const html = `
      <div class="title">
        <div>
          <h1>Level ${levelIndex+1}: ${level.name}</h1>
          <div class="subtitle">${level.hint}</div>
        </div>
        <div class="subtitle">Best: <strong>${b ? fmtTime(b) : '—'}</strong></div>
      </div>
      <div class="grid">
        <div class="panel">
          <h3>Co-op rules (mandatory)</h3>
          <ul>
            <li>Doors open only when both players are present.</li>
            <li>Switches reset if any required player leaves.</li>
            <li>Level completes only when both reach the goal together.</li>
          </ul>
        </div>
        <div class="panel">
          <h3>Tip</h3>
          <p>Stay close — the camera zooms out if you split up.</p>
          <p style="margin-top:6px;">Pressing opposite directions switches instantly (no sliding).</p>
        </div>
      </div>
      <div class="ctaRow">
        <div class="cta"><span class="k">Enter</span> Play</div>
        <div class="note"><span class="k">R</span> restart</div>
      </div>
    `;
    setOverlay(html);
  }

  function renderOverlayLevelComplete(newBest){
    const html = `
      <div class="title">
        <div>
          <h1>Level ${levelIndex+1} Complete!</h1>
          <div class="subtitle">Time: <strong>${fmtTime(levelTimeMs)}</strong> • Deaths: <strong>${deaths}</strong>${newBest ? ' • <strong style="color:var(--good)">NEW BEST!</strong>' : ''}</div>
        </div>
        <div class="subtitle">Teamwork pays off.</div>
      </div>
      <div class="grid">
        <div class="panel">
          <h3>Next challenge</h3>
          <p>${(levelIndex < 6) ? `Up next: <strong>Level ${levelIndex+2}</strong>` : 'Final results'}</p>
        </div>
        <div class="panel">
          <h3>Controls</h3>
          <p><span class="k">Enter</span> continue • <span class="k">R</span> replay level</p>
        </div>
      </div>
      <div class="ctaRow">
        <div class="cta"><span class="k">Enter</span> Continue</div>
        <div class="note">Remember: doors need both of you present.</div>
      </div>
    `;
    setOverlay(html);
  }

  function renderOverlayGameOver(){
    const html = `
      <div class="title">
        <div>
          <h1>Game Over</h1>
          <div class="subtitle">Too many mistakes for this trial. Reset and try again with a better plan.</div>
        </div>
        <div class="subtitle">Level ${levelIndex+1} • Deaths: <strong>${deaths}</strong></div>
      </div>
      <div class="grid">
        <div class="panel">
          <h3>Try</h3>
          <ul>
            <li>Call out “3…2…1… press!” for simultaneous switches.</li>
            <li>Regroup at doors — they only open if both are there.</li>
          </ul>
        </div>
        <div class="panel">
          <h3>Controls</h3>
          <p><span class="k">R</span> restart level • <span class="k">Enter</span> return to start</p>
        </div>
      </div>
      <div class="ctaRow">
        <div class="cta"><span class="k">R</span> Restart</div>
        <div class="note"></div>
      </div>
    `;
    setOverlay(html);
  }

  function renderOverlayVictory(){
    let sumBest = 0, countBest = 0;
    for (let i=0;i<7;i++){ const b=bestFor(i); if (b){ sumBest+=b; countBest++; } }
    const html = `
      <div class="title">
        <div>
          <h1>You did it — Together.</h1>
          <div class="subtitle">All 7 trials cleared. You kept in sync, stayed close, and finished as a team.</div>
        </div>
        <div class="subtitle">Best times saved locally.</div>
      </div>
      <div class="grid">
        <div class="panel">
          <h3>Stats</h3>
          <p>Session deaths (last level): <strong>${deaths}</strong></p>
          <p style="margin-top:6px;">Levels with a recorded best: <strong>${countBest}/7</strong></p>
          <p style="margin-top:6px;">Sum of bests: <strong>${countBest?fmtTime(sumBest):'—'}</strong></p>
        </div>
        <div class="panel">
          <h3>Play again</h3>
          <p><span class="k">Enter</span> back to start • <span class="k">R</span> replay Level 7</p>
        </div>
      </div>
      <div class="ctaRow">
        <div class="cta"><span class="k">Enter</span> Title</div>
        <div class="note"></div>
      </div>
    `;
    setOverlay(html);
  }

  // ===== Physics / collision =====
  function resolveX(ent, dx, solids){
    if (dx === 0) return;
    ent.x += dx;
    const r = ent.rect();
    for (const s of solids){
      if (!s.solid) continue;
      if (rectsOverlap(r, s)){
        if (dx > 0){
          ent.x = s.x - ent.w - PHYS.stepEps;
        } else {
          ent.x = s.x + s.w + PHYS.stepEps;
        }
        r.x = ent.x;
      }
    }
  }

  function resolveY(ent, dy, solids){
    ent._landedThisStep = false;
    if (dy === 0) return;
    ent.y += dy;
    const r = ent.rect();
    for (const s of solids){
      if (!s.solid) continue;
      if (rectsOverlap(r, s)){
        if (dy > 0){
          // falling onto top
          ent.y = s.y - ent.h - PHYS.stepEps;
          ent.vy = 0;
          if (!ent.grounded) ent._landedThisStep = true;
          ent.grounded = true;
          ent.coyote = 0;
          ent.lastGroundY = ent.y;
        } else {
          // hitting head
          ent.y = s.y + s.h + PHYS.stepEps;
          ent.vy = 0;
        }
        r.y = ent.y;
      }
    }
  }

  function clampToBounds(ent){
    if (!level || !level.bounds) return;
    ent.x = clamp(ent.x, level.bounds.x0, level.bounds.x1 - ent.w);
    // y unclamped (fall death)
  }

  function overlapAny(entRect, list){
    for (const a of list) if (rectsOverlap(entRect, a)) return a;
    return null;
  }

  function inLadder(entRect){
    if (!level.ladders) return null;
    for (const l of level.ladders){
      if (rectsOverlap(entRect, l)) return l;
    }
    return null;
  }

  function onControlPad(playerRect){
    if (!level.controlPads) return null;
    for (const p of level.controlPads){
      if (rectsOverlap(playerRect, p)) return p;
    }
    return null;
  }

  function updateSwitches(dt){
    const boyR = BOY.rect(), girlR = GIRL.rect();

    const byId = {};
    for (const s of (level.switches || [])) byId[s.id] = s;

    // base plates
    for (const s of (level.switches || [])){
      if (s.kind === 'timedDual') continue;
      let active = false;

      if (s.kind === 'dualPlate'){
        active = rectsOverlap(boyR, s) && rectsOverlap(girlR, s);
      } else if (s.who === 'boy'){
        active = rectsOverlap(boyR, s);
      } else if (s.who === 'girl'){
        active = rectsOverlap(girlR, s);
      } else if (s.who === 'both'){
        active = rectsOverlap(boyR, s) && rectsOverlap(girlR, s);
      }

      // For hold plates: require player also "pressing down" (S / ↓), making it more intentional.
      if (s.kind === 'holdPlate'){
        if (s.who === 'boy') active = active && isDown(BOY.controls.down);
        if (s.who === 'girl') active = active && isDown(GIRL.controls.down);
        if (s.who === 'both') active = active && isDown(BOY.controls.down) && isDown(GIRL.controls.down);
      }

      const was = !!s.active;
      s.active = !!active;
      if (s.active && !was) { sfx('switch'); }
    }

    // timed dual switches: active if both refs active simultaneously; timer holds door open.
    for (const s of (level.switches || [])){
      if (s.kind !== 'timedDual') continue;
      const a = byId[s.refs[0]];
      const b = byId[s.refs[1]];
      const nowBoth = !!(a && b && a.active && b.active);

      if (nowBoth){
        // refresh timer
        const wasActive = s.timer > 0;
        s.timer = s.maxTimer;
        if (!wasActive) sfx('switch');
      } else {
        s.timer = Math.max(0, s.timer - dt*1000);
      }
      const prev = s.active;
      s.active = s.timer > 0;
      if (!prev && s.active) { /* already did */ }
    }

    // synthetic dualPlate refs (for L6_sync): active only if both separate plates held at same time, and resets instantly if any leaves.
    for (const s of (level.switches || [])){
      if (s.kind !== 'dualPlate' || !s.refs) continue;
      const a = byId[s.refs[0]];
      const b = byId[s.refs[1]];
      const was = !!s.active;
      s.active = !!(a && b && a.active && b.active);
      if (s.active && !was) sfx('switch');
    }
  }

  function updateLevers(dt){
    if (!level.levers) return;
    const dtMs = dt*1000;
    for (const lv of level.levers){
      const boyIn = rectsOverlap(BOY.rect(), lv);
      const girlIn = rectsOverlap(GIRL.rect(), lv);
      const boyHold = boyIn && isDown(BOY.controls.down);
      const girlHold = girlIn && isDown(GIRL.controls.down);

      // must be simultaneous hold; reset if either releases/leaves
      if (boyHold && girlHold){
        lv.heldBy.boy = Math.min(lv.requiresHoldMs, lv.heldBy.boy + dtMs);
        lv.heldBy.girl = Math.min(lv.requiresHoldMs, lv.heldBy.girl + dtMs);
      } else {
        lv.heldBy.boy = 0;
        lv.heldBy.girl = 0;
      }

      const was = !!lv.active;
      lv.active = (lv.heldBy.boy >= lv.requiresHoldMs && lv.heldBy.girl >= lv.requiresHoldMs);
      if (lv.active && !was) { sfx('door'); showToast('Lever locked in! Door powered.', 1400); }
    }
  }

  function doorCondition(door){
    const byId = {};
    for (const s of (level.switches || [])) byId[s.id] = s;
    for (const l of (level.levers || [])) byId[l.id] = l;

    if (!door.requires || door.requires.length === 0) return true;
    if (door.mode === 'and'){
      for (const id of door.requires){
        const o = byId[id];
        if (!o || !o.active) return false;
      }
      return true;
    }
    // (no other mode for now)
    return false;
  }

  function bothNearDoor(door){
    const nearW = door.nearW ?? 160;
    const zone = { x: door.x - nearW, y: door.y - 30, w: door.w + nearW*2, h: door.h + 60 };
    return rectsOverlap(BOY.rect(), zone) && rectsOverlap(GIRL.rect(), zone);
  }

  function updateDoors(){
    for (const d of (level.doors || [])){
      const can = doorCondition(d);
      const near = bothNearDoor(d);
      const openNow = !!(can && near);
      if (openNow && !d.open) { sfx('door'); showToast('Door unlocked — go together!', 1200); }
      d.open = openNow;
    }
  }

  function updateTraps(dt){
    // cycles for crushers
    for (const t of (level.traps || [])){
      let disabled = false;
      if (t.disabledBy && t.disabledBy.length){
        const byId = {};
        for (const s of (level.switches || [])) byId[s.id] = s;
        for (const id of t.disabledBy){
          if (byId[id] && byId[id].active) { disabled = true; break; }
        }
      }
      if (t.kind === 'crusher' && t.cycle){
        t.cycle.t += dt;
        const phaseT = (t.cycle.t / t.cycle.period + t.cycle.phase) % 1;
        const pulseOn = phaseT < t.cycle.duty;
        t.active = pulseOn && !disabled;
      } else {
        t.active = !disabled;
      }
    }
  }

  function buildSolids(){
    const solids = [];

    // static solids
    for (const s of (level.solids || [])){
      solids.push({x:s.x,y:s.y,w:s.w,h:s.h, solid:true, kind:s.kind || 'platform'});
    }

    // bridges
    if (level.bridges){
      const byId = {};
      for (const sw of (level.switches || [])) byId[sw.id] = sw;
      for (const b of level.bridges){
        const enabled = !!(byId[b.enabledBy] && byId[b.enabledBy].active);
        if (enabled) solids.push({x:b.x,y:b.y,w:b.w,h:b.h, solid:true, kind:'bridge'});
      }
    }

    // moving platforms are solid
    for (const m of (level.moving || [])){
      solids.push({x:m.x,y:m.y,w:m.w,h:m.h, solid:true, kind:'moving', ref:m});
    }

    // doors are solid when closed
    for (const d of (level.doors || [])){
      if (!d.open){
        solids.push({x:d.x,y:d.y,w:d.w,h:d.h, solid:true, kind:'door', ref:d});
      }
    }

    // crates are solid
    for (const c of (level.crates || [])){
      solids.push({x:c.x,y:c.y,w:c.w,h:c.h, solid:true, kind:'crate', ref:c});
    }

    return solids;
  }

  function updateMovingPlatforms(dt){
    const boyR = BOY.rect(), girlR = GIRL.rect();
    for (const m of (level.moving || [])){
      m.vx = 0; m.vy = 0;
      if (m.mode === 'auto'){
        m.t = (m.t || 0) + dt;
        // (not used currently)
      } else if (m.mode === 'controlled'){
        // platform moves only while controller stands on control pad
        const controller = (m.controller === 'boy') ? BOY : GIRL;
        const pad = onControlPad(controller.rect());
        const ok = pad && pad.who === m.controller;
        const dir = dirFromKeys(controller.controls.left, controller.controls.right);
        const targetV = ok ? dir * 220 : 0;
        m.vx = targetV;
        const nx = m.x + m.vx * dt;
        m.x = clamp(nx, m.bounds.min, m.bounds.max);
      }
    }

    // carry players standing on top of moving platforms (deterministic, no inertia)
    for (const p of players){
      if (!p.grounded) continue;
      const feet = {x:p.x+2, y:p.y+p.h, w:p.w-4, h:2};
      for (const m of (level.moving || [])){
        const topBand = {x:m.x, y:m.y-1.5, w:m.w, h:5};
        if (rectsOverlap(feet, topBand)){
          // Apply horizontal displacement from platform this step.
          p.x += m.vx * dt;
        }
      }
    }
  }

  function updateCrates(dt, solids){
    // Deterministic push: if player overlaps a crate horizontally while moving, move crate by same dx, then resolve against other solids.
    if (!level.crates || level.crates.length === 0) return;
    const staticSolids = solids.filter(s => s.kind !== 'crate');

    for (const c of level.crates){
      c.vx = 0;
      const crateRect = {x:c.x,y:c.y,w:c.w,h:c.h};

      // see if a player is pushing
      for (const p of players){
        const dir = dirFromKeys(p.controls.left, p.controls.right);
        const vx = dir * PHYS.moveSpeed;
        if (vx === 0) continue;
        const pr = p.rect();
        if (!rectsOverlap(pr, crateRect)) continue;

        // must be lateral contact-ish: intersect and near same vertical band
        const vOverlap = (pr.y + pr.h) > crateRect.y + 6 && pr.y < crateRect.y + crateRect.h - 6;
        if (!vOverlap) continue;

        // determine pushing side
        if (vx > 0 && pr.x + pr.w <= crateRect.x + 18){
          c.vx = Math.max(c.vx, vx);
        } else if (vx < 0 && pr.x >= crateRect.x + crateRect.w - 18){
          c.vx = Math.min(c.vx, vx);
        }
      }

      if (c.vx !== 0){
        c.x += c.vx * dt;
        // resolve crate against static solids and doors/moving
        for (const s of staticSolids){
          if (!s.solid) continue;
          const rr = {x:c.x,y:c.y,w:c.w,h:c.h};
          if (rectsOverlap(rr, s)){
            if (c.vx > 0) c.x = s.x - c.w - PHYS.stepEps;
            else c.x = s.x + s.w + PHYS.stepEps;
          }
        }
      }
    }
  }

  function killAndRespawn(){
    deaths++;
    hudDeaths.textContent = deaths.toString();
    shake(10, 0.2);
    sfx('hurt');

    // respawn both (co-op consequence)
    BOY.setSpawn(level.spawns[0]);
    GIRL.setSpawn(level.spawns[1]);

    // reset certain temporary mechanisms
    for (const s of (level.switches || [])){
      if (s.kind === 'timedDual'){ s.timer = 0; s.active = false; }
      if (s.kind === 'holdPlate') s.active = false;
    }
    for (const d of (level.doors || [])) d.open = false;
    for (const lv of (level.levers || [])){ lv.active=false; lv.heldBy={boy:0,girl:0}; }

    // game over threshold
    if (deaths >= 20){
      state = 'gameOver';
      renderOverlayGameOver();
    }
  }

  // ===== Player update (NO horizontal inertia, last key press wins) =====
  function updatePlayer(p, dt, solids){
    p.animT += dt;
    p._jumpedThisStep = false;

    const dir = dirFromKeys(p.controls.left, p.controls.right);
    if (dir !== 0) p.facing = dir;

    // ladder check
    const ladder = inLadder(p.rect());
    const upDown = (isDown(p.controls.up) ? -1 : 0) + (isDown(p.controls.down) ? 1 : 0);

    if (ladder && upDown !== 0){
      // enter/continue ladder
      p.onLadder = true;
    } else if (!ladder){
      p.onLadder = false;
    }

    // Horizontal: deterministic, no drift
    const vx = dir * PHYS.moveSpeed;
    resolveX(p, vx * dt, solids);

    // Vertical:
    if (p.onLadder){
      p.vy = upDown * PHYS.climbSpeed;
      // while on ladder, ignore gravity and "grounded" isn't sticky
      p.grounded = false;
      resolveY(p, p.vy * dt, solids);
    } else {
      // jump only when grounded
      if (wasPressed(p.controls.up) && p.grounded){
        p.vy = -PHYS.jumpVel;
        p.grounded = false;
        p._jumpedThisStep = true;
        sfx('jump');
        shake(3, 0.08);
      }
      // gravity
      p.vy = clamp(p.vy + PHYS.gravity * dt, -9999, PHYS.maxFall);
      resolveY(p, p.vy * dt, solids);
    }

    // Clamp horizontally to bounds
    clampToBounds(p);

    // landing SFX
    if (p._landedThisStep) sfx('land');

    // state
    if (state !== 'playing'){
      if (state === 'levelComplete' || state === 'victory') p.state = 'celebrate';
      else p.state = 'idle';
      return;
    }

    if (p.onLadder){
      p.state = 'climb';
    } else if (!p.grounded){
      p.state = (p.vy < 0) ? 'jump' : 'fall';
    } else if (dir !== 0){
      p.state = 'run';
    } else if (isDown(p.controls.down)){
      p.state = 'push'; // crouch / press
    } else {
      p.state = 'idle';
    }
  }

  // ===== Win/lose checks =====
  function updateGoalAndHazards(){
    // fall death
    if (BOY.y > level.failY || GIRL.y > level.failY){
      killAndRespawn();
      return;
    }

    // traps
    for (const t of (level.traps || [])){
      if (!t.active) continue;
      const hitRect = (t.kind === 'spike')
        ? {x:t.x, y:t.y-6, w:t.w, h:t.h+6}
        : {x:t.x, y:t.y-10, w:t.w, h:t.h+10};

      if (rectsOverlap(BOY.rect(), hitRect) || rectsOverlap(GIRL.rect(), hitRect)){
        killAndRespawn();
        return;
      }
    }

    // goal requires both inside at once
    if (level.goal){
      const inBoy = rectsOverlap(BOY.rect(), level.goal);
      const inGirl = rectsOverlap(GIRL.rect(), level.goal);
      if (inBoy && inGirl){
        if (state === 'playing'){
          state = 'levelComplete';
          const newBest = setBest(levelIndex, levelTimeMs);
          hudBest.textContent = bestFor(levelIndex) ? fmtTime(bestFor(levelIndex)) : '—';
          sfx('goal');
          sfx('win');
          renderOverlayLevelComplete(newBest);
        }
      }
    }
  }

  // ===== Rendering =====
  function drawRoundedRect(x,y,w,h,r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  function drawPlatform(s){
    const k = s.kind || 'platform';
    if (k === 'ground'){
      ctx.fillStyle = 'rgba(234,242,255,0.08)';
      ctx.fillRect(s.x, s.y, s.w, s.h);
      // top edge
      ctx.fillStyle = 'rgba(234,242,255,0.14)';
      ctx.fillRect(s.x, s.y, s.w, 3);
    } else if (k === 'moving'){
      ctx.fillStyle = 'rgba(99,255,167,0.16)';
      drawRoundedRect(s.x, s.y, s.w, s.h, 7);
      ctx.fillStyle = 'rgba(99,255,167,0.26)';
      ctx.fillRect(s.x+10, s.y+3, s.w-20, 2);
    } else if (k === 'door'){
      // solid door body
      const d = s.ref;
      ctx.fillStyle = d.open ? 'rgba(99,255,167,0.10)' : 'rgba(234,242,255,0.10)';
      drawRoundedRect(s.x, s.y, s.w, s.h, 10);
      ctx.fillStyle = d.open ? 'rgba(99,255,167,0.55)' : 'rgba(255,213,106,0.55)';
      ctx.fillRect(s.x+6, s.y+10, s.w-12, 6);
      ctx.fillStyle = 'rgba(0,0,0,0.18)';
      ctx.fillRect(s.x+5, s.y+22, s.w-10, s.h-30);
      // lock indicator
      ctx.fillStyle = d.open ? 'rgba(99,255,167,0.70)' : 'rgba(255,213,106,0.75)';
      ctx.beginPath();
      ctx.arc(s.x + s.w/2, s.y + 18, 4, 0, Math.PI*2);
      ctx.fill();
    } else if (k === 'bridge'){
      ctx.fillStyle = 'rgba(74,163,255,0.12)';
      drawRoundedRect(s.x, s.y, s.w, s.h, 10);
      ctx.fillStyle = 'rgba(195,92,255,0.10)';
      ctx.fillRect(s.x+8, s.y+3, s.w-16, 2);
    } else if (k === 'crate'){
      ctx.fillStyle = 'rgba(255,213,106,0.14)';
      drawRoundedRect(s.x, s.y, s.w, s.h, 8);
      ctx.fillStyle = 'rgba(255,213,106,0.26)';
      ctx.fillRect(s.x+6, s.y+6, s.w-12, 4);
      ctx.fillStyle = 'rgba(0,0,0,0.20)';
      ctx.fillRect(s.x+6, s.y+14, s.w-12, s.h-20);
    } else {
      ctx.fillStyle = 'rgba(234,242,255,0.10)';
      drawRoundedRect(s.x, s.y, s.w, s.h, 9);
      ctx.fillStyle = 'rgba(234,242,255,0.18)';
      ctx.fillRect(s.x+8, s.y+3, s.w-16, 2);
    }
  }

  function drawSwitch(sw){
    const pulse = 0.5 + 0.5*Math.sin((performance.now()/1000)*3.2);
    const active = !!sw.active;
    const base = active ? 'rgba(99,255,167,0.24)' : 'rgba(255,213,106,0.18)';
    const rim  = active ? 'rgba(99,255,167,0.70)' : 'rgba(255,213,106,0.55)';
    ctx.fillStyle = base;
    drawRoundedRect(sw.x, sw.y, sw.w, sw.h, 8);
    ctx.fillStyle = rim;
    ctx.fillRect(sw.x+6, sw.y+3, sw.w-12, 2);
    // glow
    ctx.globalAlpha = active ? 0.35 : 0.24 + 0.12*pulse;
    ctx.fillStyle = active ? 'rgba(99,255,167,0.65)' : 'rgba(255,213,106,0.60)';
    ctx.beginPath();
    ctx.ellipse(sw.x+sw.w/2, sw.y+sw.h/2, sw.w*0.75, sw.h*1.4, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  function drawLadder(l){
    ctx.fillStyle = 'rgba(234,242,255,0.08)';
    drawRoundedRect(l.x, l.y, l.w, l.h, 12);
    ctx.fillStyle = 'rgba(234,242,255,0.16)';
    // rails
    ctx.fillRect(l.x+10, l.y+10, 4, l.h-20);
    ctx.fillRect(l.x+l.w-14, l.y+10, 4, l.h-20);
    // rungs
    ctx.fillStyle = 'rgba(234,242,255,0.14)';
    for (let y=l.y+18; y<l.y+l.h-18; y+=18){
      ctx.fillRect(l.x+12, y, l.w-24, 3);
    }
  }

  function drawTrap(t){
    const pulse = 0.5 + 0.5*Math.sin((performance.now()/1000)*5.5 + (t.x*0.01));
    if (t.kind === 'spike'){
      // bed
      ctx.fillStyle = t.active ? 'rgba(255,107,136,0.18)' : 'rgba(234,242,255,0.05)';
      drawRoundedRect(t.x, t.y, t.w, t.h, 8);
      // spikes
      const n = Math.max(3, Math.floor(t.w/20));
      for (let i=0;i<n;i++){
        const x0 = t.x + (i/n)*t.w;
        const x1 = t.x + ((i+1)/n)*t.w;
        const xm = (x0+x1)/2;
        const h = 18 + 4*pulse;
        ctx.beginPath();
        ctx.moveTo(x0+2, t.y+t.h);
        ctx.lineTo(xm, t.y+t.h-h);
        ctx.lineTo(x1-2, t.y+t.h);
        ctx.closePath();
        ctx.fillStyle = t.active ? 'rgba(255,107,136,0.65)' : 'rgba(234,242,255,0.18)';
        ctx.fill();
      }
      // warning glow if active
      if (t.active){
        ctx.globalAlpha = 0.20 + 0.12*pulse;
        ctx.fillStyle = 'rgba(255,107,136,0.55)';
        ctx.beginPath();
        ctx.ellipse(t.x+t.w/2, t.y+t.h/2, t.w*0.7, t.h*2.2, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    } else {
      // crusher bar
      ctx.fillStyle = t.active ? 'rgba(255,107,136,0.26)' : 'rgba(234,242,255,0.06)';
      drawRoundedRect(t.x, t.y, t.w, t.h, 9);
      ctx.fillStyle = t.active ? 'rgba(255,107,136,0.75)' : 'rgba(234,242,255,0.18)';
      ctx.fillRect(t.x+8, t.y+4, t.w-16, 3);
      if (t.active){
        ctx.globalAlpha = 0.18 + 0.12*pulse;
        ctx.fillStyle = 'rgba(255,107,136,0.55)';
        ctx.fillRect(t.x-6, t.y-10, t.w+12, t.h+20);
        ctx.globalAlpha = 1;
      }
    }
  }

  function drawGoal(g){
    const t = performance.now()/1000;
    const pulse = 0.55 + 0.45*Math.sin(t*2.4);
    ctx.fillStyle = 'rgba(99,255,167,0.12)';
    drawRoundedRect(g.x, g.y, g.w, g.h, 14);
    ctx.globalAlpha = 0.25 + 0.25*pulse;
    ctx.fillStyle = 'rgba(99,255,167,0.70)';
    ctx.beginPath();
    ctx.ellipse(g.x+g.w/2, g.y+g.h/2, g.w*0.9, g.h*0.75, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // flag
    ctx.fillStyle = 'rgba(234,242,255,0.20)';
    ctx.fillRect(g.x+10, g.y+8, 3, g.h-16);
    ctx.fillStyle = 'rgba(99,255,167,0.65)';
    ctx.beginPath();
    ctx.moveTo(g.x+13, g.y+12);
    ctx.lineTo(g.x+g.w-8, g.y+18);
    ctx.lineTo(g.x+13, g.y+26);
    ctx.closePath();
    ctx.fill();
  }

  function drawLever(lv){
    const t = performance.now()/1000;
    const pulse = 0.5 + 0.5*Math.sin(t*4.0);
    const prog = Math.min(1, Math.min(lv.heldBy.boy, lv.heldBy.girl)/lv.requiresHoldMs);
    ctx.fillStyle = 'rgba(234,242,255,0.07)';
    drawRoundedRect(lv.x, lv.y, lv.w, lv.h, 12);
    ctx.fillStyle = lv.active ? 'rgba(99,255,167,0.60)' : 'rgba(255,213,106,0.55)';
    // handle
    const hx = lv.x + lv.w/2;
    const hy = lv.y + lv.h/2;
    const ang = lv.active ? -0.9 : lerp(0.3, -0.5, prog);
    const len = 18;
    ctx.save();
    ctx.translate(hx, hy);
    ctx.rotate(ang);
    ctx.fillRect(-2, -len, 4, len+8);
    ctx.beginPath(); ctx.arc(0, -len, 6, 0, Math.PI*2); ctx.fill();
    ctx.restore();

    // progress ring glow
    if (!lv.active){
      ctx.globalAlpha = 0.18 + 0.10*pulse;
      ctx.fillStyle = 'rgba(255,213,106,0.55)';
      ctx.beginPath();
      ctx.ellipse(lv.x+lv.w/2, lv.y+lv.h/2, lv.w*0.65, lv.h*0.75, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    // progress bar
    ctx.fillStyle = 'rgba(0,0,0,0.22)';
    ctx.fillRect(lv.x+8, lv.y+lv.h-10, lv.w-16, 5);
    ctx.fillStyle = lv.active ? 'rgba(99,255,167,0.75)' : 'rgba(255,213,106,0.75)';
    ctx.fillRect(lv.x+8, lv.y+lv.h-10, (lv.w-16)*prog, 5);
  }

  function drawPlayer(p){
    const t = p.animT;
    const x = p.x, y = p.y;
    const w = p.w, h = p.h;

    // animation parameters
    const run = (p.state === 'run');
    const jump = (p.state === 'jump' || p.state === 'fall');
    const climb = (p.state === 'climb');
    const press = (p.state === 'push');
    const celebrate = (p.state === 'celebrate');

    const bob = run ? Math.sin(t*14)*1.3 : (celebrate ? Math.sin(t*8)*2.0 : Math.sin(t*2.2)*0.6);
    const lean = run ? (p.facing * 0.08) : (jump ? (p.facing * 0.03) : 0);
    const legSwing = run ? Math.sin(t*16) : (climb ? Math.sin(t*12) : 0);
    const armSwing = run ? -Math.sin(t*16) : (climb ? -Math.sin(t*12) : 0);
    const headTilt = jump ? (p.vy < 0 ? -0.08 : 0.10) : (press ? 0.12 : 0);

    // body proportions (cartoon big head)
    const headR = 16;
    const bodyH = 20;
    const bodyW = 22;
    const bodyX = x + w/2;
    const bodyY = y + 22 + bob;

    ctx.save();
    ctx.translate(bodyX, bodyY);
    ctx.scale(p.facing, 1);
    ctx.rotate(lean);

    // shadow on ground if close
    if (p.grounded && !climb){
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.beginPath();
      ctx.ellipse(0, h/2 + 10, 15, 5, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // legs
    const legY = 18;
    const legLen = 15;
    const legOff = 6;
    function drawLeg(side){
      const s = side;
      const a = (run ? (legSwing * 0.55 * s) : (climb ? (legSwing * 0.35 * s) : 0));
      ctx.save();
      ctx.translate(legOff*s, legY);
      ctx.rotate(a);
      ctx.fillStyle = 'rgba(6,16,26,0.90)';
      ctx.fillRect(-3, 0, 6, legLen);
      // sneaker
      ctx.fillStyle = (p.id===0) ? 'rgba(156,210,255,0.88)' : 'rgba(255,209,242,0.88)';
      ctx.fillRect(-6, legLen-2, 12, 5);
      ctx.restore();
    }
    drawLeg(-1);
    drawLeg(1);

    // torso / hoodie/jacket
    ctx.fillStyle = (p.id===0) ? 'rgba(74,163,255,0.90)' : 'rgba(195,92,255,0.88)';
    drawRoundedRect(-bodyW/2, 2, bodyW, bodyH, 10);

    // hoodie/jacket accent
    ctx.fillStyle = (p.id===0) ? 'rgba(31,111,224,0.70)' : 'rgba(255,74,168,0.60)';
    ctx.fillRect(-bodyW/2+3, 8, bodyW-6, 3);

    // arms
    function drawArm(side){
      const s = side;
      const a = (run ? (armSwing * 0.55 * s) : (climb ? (armSwing * 0.35 * s) : (press ? 0.9 : 0.15*s)));
      ctx.save();
      ctx.translate((bodyW/2 - 2)*s, 8);
      ctx.rotate(a);
      ctx.fillStyle = (p.id===0) ? 'rgba(31,111,224,0.85)' : 'rgba(255,74,168,0.72)';
      ctx.fillRect(-2, 0, 4, 14);
      // hand
      ctx.fillStyle = 'rgba(255,231,212,0.92)';
      ctx.beginPath();
      ctx.arc(0, 15, 4, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    drawArm(-1);
    drawArm(1);

    // head
    ctx.save();
    ctx.translate(0, -8);
    ctx.rotate(headTilt);

    // face base
    ctx.fillStyle = 'rgba(255,231,212,0.96)';
    ctx.beginPath();
    ctx.arc(0, 0, headR, 0, Math.PI*2);
    ctx.fill();

    // hair
    if (p.id === 0){
      // boy: short hair
      ctx.fillStyle = 'rgba(20,26,36,0.95)';
      ctx.beginPath();
      ctx.arc(0, -4, headR, Math.PI, Math.PI*2);
      ctx.closePath();
      ctx.fill();
      ctx.fillRect(-headR+2, -8, headR*2-4, 8);
    } else {
      // girl: ponytail
      ctx.fillStyle = 'rgba(28,16,40,0.92)';
      ctx.beginPath();
      ctx.arc(0, -4, headR, Math.PI, Math.PI*2);
      ctx.closePath();
      ctx.fill();
      // ponytail blob
      ctx.globalAlpha = 0.92;
      ctx.beginPath();
      ctx.ellipse(headR-2, 2, 9, 8, 0.2, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // expressions by state
    // eyes
    let eyeY = -1;
    let eyeOpen = 1;
    let brow = 0;
    let mouth = 'smile';
    if (p.state === 'idle'){
      mouth = (p.id===0) ? 'smile' : 'cheer';
      brow = 0;
      eyeOpen = 1;
    } else if (p.state === 'run'){
      mouth = (p.id===0) ? 'determined' : 'excited';
      brow = (p.id===0) ? -1 : -0.6;
      eyeOpen = 0.85;
    } else if (p.state === 'jump'){
      mouth = (p.id===0) ? 'intense' : 'focus';
      brow = -0.8;
      eyeOpen = 0.95;
      eyeY = -2;
    } else if (p.state === 'fall'){
      mouth = (p.id===0) ? 'surprised' : 'focus';
      brow = 0.2;
      eyeOpen = 1.05;
      eyeY = 0;
    } else if (p.state === 'push'){
      mouth = (p.id===0) ? 'grit' : 'grit';
      brow = -0.8;
      eyeOpen = 0.8;
    } else if (p.state === 'climb'){
      mouth = 'focus';
      brow = -0.6;
      eyeOpen = 0.9;
    } else if (p.state === 'celebrate'){
      mouth = 'bigsmile';
      brow = -0.4;
      eyeOpen = 1.0;
    }

    // eyes positions (relative)
    const ex = 6, ey = eyeY;
    ctx.fillStyle = 'rgba(6,16,26,0.92)';
    // left eye
    ctx.save();
    ctx.translate(-ex, ey);
    ctx.scale(1, eyeOpen);
    ctx.beginPath(); ctx.ellipse(0,0,2.2,2.6,0,0,Math.PI*2); ctx.fill();
    ctx.restore();
    // right eye
    ctx.save();
    ctx.translate(ex, ey);
    ctx.scale(1, eyeOpen);
    ctx.beginPath(); ctx.ellipse(0,0,2.2,2.6,0,0,Math.PI*2); ctx.fill();
    ctx.restore();

    // brows
    ctx.strokeStyle = 'rgba(6,16,26,0.70)';
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(-9, -6 + brow);
    ctx.lineTo(-3, -7 + brow);
    ctx.moveTo(3, -7 + brow);
    ctx.lineTo(9, -6 + brow);
    ctx.stroke();

    // mouth
    ctx.strokeStyle = 'rgba(6,16,26,0.75)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    if (mouth === 'smile' || mouth === 'cheer'){
      ctx.arc(0, 6, 6, 0, Math.PI, false);
    } else if (mouth === 'excited'){
      ctx.arc(0, 7, 6, 0, Math.PI, false);
      ctx.moveTo(-3, 8);
      ctx.lineTo(3, 8);
    } else if (mouth === 'determined'){
      ctx.moveTo(-5, 7);
      ctx.lineTo(5, 7);
    } else if (mouth === 'intense'){
      ctx.moveTo(-4, 7);
      ctx.lineTo(4, 6);
    } else if (mouth === 'surprised'){
      ctx.fillStyle = 'rgba(6,16,26,0.70)';
      ctx.beginPath(); ctx.ellipse(0, 7, 3.2, 4.0, 0, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); // to avoid extra stroke
    } else if (mouth === 'focus'){
      ctx.moveTo(-4, 7);
      ctx.quadraticCurveTo(0, 9, 4, 7);
    } else if (mouth === 'grit'){
      ctx.moveTo(-5, 8);
      ctx.lineTo(5, 8);
      ctx.moveTo(-4, 6);
      ctx.lineTo(4, 6);
    } else if (mouth === 'bigsmile'){
      ctx.arc(0, 7, 7, 0, Math.PI, false);
    }
    ctx.stroke();

    // blush for girl
    if (p.id === 1 && (p.state === 'idle' || p.state === 'celebrate')){
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = 'rgba(255,74,168,0.9)';
      ctx.beginPath(); ctx.ellipse(-9, 3, 3.2, 2.2, 0, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(9, 3, 3.2, 2.2, 0, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }

    ctx.restore(); // head

    // name tag tiny
    ctx.globalAlpha = 0.75;
    ctx.fillStyle = (p.id===0) ? 'rgba(74,163,255,0.35)' : 'rgba(195,92,255,0.30)';
    drawRoundedRect(-18, -38, 36, 12, 6);
    ctx.fillStyle = 'rgba(234,242,255,0.82)';
    ctx.font = '700 9px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(p.id===0 ? 'BOY' : 'GIRL', 0, -32);
    ctx.globalAlpha = 1;

    ctx.restore();
  }

  function drawBackground(){
    // parallax stars
    const t = performance.now()/1000;
    const w = canvas.width / DPR;
    const h = canvas.height / DPR;

    // vignette
    ctx.save();
    ctx.setTransform(DPR,0,0,DPR,0,0);
    const g = ctx.createRadialGradient(w*0.5, h*0.35, 40, w*0.5, h*0.45, Math.max(w,h)*0.75);
    g.addColorStop(0, 'rgba(0,0,0,0)');
    g.addColorStop(1, 'rgba(0,0,0,0.35)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
    ctx.restore();

    // in-world haze layers
    ctx.globalAlpha = 0.5;
    ctx.fillStyle = 'rgba(74,163,255,0.05)';
    ctx.fillRect(cam.x - 1000, 0, 4000, 300);
    ctx.fillStyle = 'rgba(195,92,255,0.04)';
    ctx.fillRect(cam.x - 1200, 280, 4200, 260);
    ctx.globalAlpha = 1;

    // distant "mountains" as simple waves
    function ridge(yBase, amp, color, speed){
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      const startX = cam.x - 1400;
      const endX = cam.x + 1400;
      for (let x=startX; x<=endX; x+=26){
        const y = yBase + Math.sin((x*0.003) + t*speed)*amp + Math.sin((x*0.006) - t*speed*0.8)*(amp*0.5);
        if (x===startX) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }
    ridge(140, 10, 'rgba(234,242,255,0.06)', 0.6);
    ridge(220, 14, 'rgba(234,242,255,0.05)', 0.45);
  }

  function drawWorld(){
    // build camera transform
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // world camera
    const viewW = canvas.width / DPR;
    const viewH = canvas.height / DPR;

    // shake
    let shx = 0, shy = 0;
    if (cam.shakeT > 0){
      const s = cam.shakeMag * (cam.shakeT / 0.2);
      shx = (Math.random()*2-1) * s;
      shy = (Math.random()*2-1) * s;
    }

    ctx.save();
    ctx.setTransform(DPR,0,0,DPR,0,0);
    ctx.restore();

    ctx.save();
    ctx.setTransform(DPR,0,0,DPR, viewW/2 + shx, viewH/2 + shy);
    ctx.scale(cam.scale, cam.scale);
    ctx.translate(-cam.x, -cam.y);

    drawBackground();

    // ladders
    for (const l of (level.ladders || [])) drawLadder(l);

    // switches
    for (const s of (level.switches || [])){
      if (s.kind === 'timedDual' && s.w === 0) continue; // hidden
      if (s.kind === 'dualPlate' && s.refs) continue; // hidden synthetic
      drawSwitch(s);
    }

    // levers
    for (const lv of (level.levers || [])) drawLever(lv);

    // moving platform hint: control pads
    if (level.controlPads){
      for (const p of level.controlPads){
        const pulse = 0.5 + 0.5*Math.sin((performance.now()/1000)*4.0);
        ctx.fillStyle = (p.who==='boy') ? 'rgba(74,163,255,0.14)' : 'rgba(195,92,255,0.14)';
        drawRoundedRect(p.x, p.y, p.w, p.h, 8);
        ctx.globalAlpha = 0.18 + 0.16*pulse;
        ctx.fillStyle = (p.who==='boy') ? 'rgba(74,163,255,0.55)' : 'rgba(195,92,255,0.55)';
        ctx.beginPath();
        ctx.ellipse(p.x+p.w/2, p.y+p.h/2, p.w*0.8, p.h*1.6, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }

    // traps
    for (const t of (level.traps || [])) drawTrap(t);

    // solids
    const solids = buildSolids();
    for (const s of solids){
      // draw only actual visible solids (skip hidden internal)
      drawPlatform(s);
    }

    // goal
    if (level.goal) drawGoal(level.goal);

    // players
    drawPlayer(BOY);
    drawPlayer(GIRL);

    // line between players to emphasize coop + camera
    const midx = (BOY.x+BOY.w/2 + GIRL.x+GIRL.w/2)/2;
    const midy = (BOY.y+BOY.h/2 + GIRL.y+GIRL.h/2)/2;
    const dx = (BOY.x+BOY.w/2) - (GIRL.x+GIRL.w/2);
    const dist = Math.abs(dx);
    ctx.globalAlpha = clamp((dist-240)/480, 0, 0.35);
    ctx.strokeStyle = 'rgba(234,242,255,0.8)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(BOY.x+BOY.w/2, BOY.y+BOY.h/2);
    ctx.lineTo(GIRL.x+GIRL.w/2, GIRL.y+GIRL.h/2);
    ctx.stroke();
    // warning dot
    ctx.fillStyle = 'rgba(255,213,106,0.85)';
    ctx.beginPath();
    ctx.arc(midx, midy-28, 4 + 2*Math.sin(performance.now()/1000*6), 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.restore();

    // screen-space vignette
    ctx.save();
    ctx.setTransform(DPR,0,0,DPR,0,0);
    const vg = ctx.createRadialGradient(viewW*0.5, viewH*0.35, Math.min(viewW,viewH)*0.2, viewW*0.5, viewH*0.45, Math.max(viewW,viewH)*0.75);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(0,0,0,0.28)');
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,viewW,viewH);
    ctx.restore();
  }

  // ===== Camera update =====
  function updateCamera(dt){
    const bx = BOY.x + BOY.w/2, by = BOY.y + BOY.h/2;
    const gx = GIRL.x + GIRL.w/2, gy = GIRL.y + GIRL.h/2;

    const cx = (bx + gx)/2;
    const cy = (by + gy)/2;

    const distX = Math.abs(bx - gx);
    const distY = Math.abs(by - gy);

    const viewW = canvas.width / DPR;
    const viewH = canvas.height / DPR;

    // keep both on screen with margin
    const marginX = 520;
    const marginY = 320;
    const sX = viewW / (distX + marginX);
    const sY = viewH / (distY + marginY);
    let targetS = Math.min(sX, sY);
    targetS = clamp(targetS, 0.72, 1.28);

    cam.x = lerp(cam.x, cx, 1 - Math.pow(0.0008, dt));
    cam.y = lerp(cam.y, cy, 1 - Math.pow(0.0008, dt));
    cam.scale = lerp(cam.scale, targetS, 1 - Math.pow(0.0015, dt));

    // clamp camera into bounds a bit
    if (level && level.bounds){
      const halfW = (viewW/2) / cam.scale;
      const halfH = (viewH/2) / cam.scale;
      cam.x = clamp(cam.x, level.bounds.x0 + halfW, level.bounds.x1 - halfW);
      cam.y = clamp(cam.y, level.bounds.y0 + halfH, level.bounds.y1 - halfH);
    }

    if (cam.shakeT > 0){
      cam.shakeT = Math.max(0, cam.shakeT - dt);
      if (cam.shakeT === 0) cam.shakeMag = 0;
    }
  }

  // ===== Main loop (fixed timestep) =====
  let last = performance.now();
  let acc = 0;
  const FIXED = 1/120;

  function step(dt){
    if (toastTimer > 0){
      toastTimer -= dt*1000;
      if (toastTimer <= 0) hideToast();
    }

    if (state === 'playing'){
      levelTimeMs += dt*1000;
      hudTime.textContent = fmtTime(levelTimeMs);
    }

    // Update mechanisms even in intro? minimal
    if (state === 'playing'){
      updateSwitches(dt);
      updateLevers(dt);
      updateDoors();
      updateTraps(dt);

      updateMovingPlatforms(dt);

      // Build solids for collision
      const solids = buildSolids();

      // crate pushing needs solids
      updateCrates(dt, solids);

      // refresh solids after crate moved (simple: rebuild)
      const solids2 = buildSolids();

      // Update players
      updatePlayer(BOY, dt, solids2);
      updatePlayer(GIRL, dt, solids2);

      updateGoalAndHazards();

      // keep time deterministic: re-evaluate doors after player movement (near door)
      updateDoors();
    } else {
      // minimal animations and camera
      for (const p of players) p.animT += dt;
      if (level){
        updateSwitches(dt);
        updateLevers(dt);
        updateDoors();
        updateTraps(dt);
        updateMovingPlatforms(dt);
      }
    }

    updateCamera(dt);
  }

  function loop(now){
    resize();
    const delta = Math.min(0.06, (now - last)/1000);
    last = now;

    acc += delta;
    while (acc >= FIXED){
      step(FIXED);
      acc -= FIXED;
      JUST_PRESSED.clear();
      JUST_RELEASED.clear();
    }

    drawWorld();
    requestAnimationFrame(loop);
  }

  // ===== Global controls (states) =====
  function goToStart(){
    state = 'start';
    renderOverlayStart();
    if (!level) loadLevel(0); // ensure level exists for background draw
  }

  window.addEventListener('keydown', (e)=>{
    if (e.code === 'Escape'){
      if (state === 'playing'){
        state = 'intro';
        renderOverlayIntro();
      } else if (state === 'intro'){
        state = 'playing';
        hideOverlay();
      } else if (state === 'start'){
        // no-op
      } else if (state === 'levelComplete' || state === 'gameOver' || state === 'victory'){
        // no-op
      }
    }

    if (e.code === 'KeyR'){
      if (state === 'playing' || state === 'intro' || state === 'levelComplete' || state === 'gameOver'){
        restartLevel();
      } else if (state === 'victory'){
        loadLevel(6);
        state = 'intro';
        renderOverlayIntro();
      }
    }

    if (e.code === 'Enter'){
      if (state === 'start'){
        // start at level 1
        loadLevel(0);
        state = 'playing';
        hideOverlay();
        showToast(level.hint, 2400);
      } else if (state === 'intro'){
        state = 'playing';
        hideOverlay();
      } else if (state === 'levelComplete'){
        nextLevel();
        if (state === 'intro'){ /* loadLevel did that */ }
        if (state === 'playing'){ hideOverlay(); }
      } else if (state === 'gameOver'){
        goToStart();
      } else if (state === 'victory'){
        goToStart();
      }
    }
  });

  // ===== Kickoff =====
  loadLevel(0);
  goToStart();
  hudTime.textContent = fmtTime(0);
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>